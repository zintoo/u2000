<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>omniORB</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea omniORB -->
<!--CUT DEF chapter 1 --><DIV CLASS="center"><P> <FONT SIZE=7>The omniORB version 4.2<BR>
Users&#X2019; Guide
</FONT></P><P> <FONT SIZE=5>Duncan Grisby<BR>
</FONT><FONT SIZE=3>(</FONT><A HREF="mailto:dgrisby@apasphere.com"><FONT SIZE=3><I><FONT COLOR=purple>dgrisby@apasphere.com</FONT></I></FONT></A><FONT SIZE=3>)</FONT><FONT SIZE=5><BR>
</FONT></P></DIV><P><FONT SIZE=5><B>Contents</B></FONT></P><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>omniORB is an Object Request Broker (ORB) that implements version 2.6
of the Common Object Request Broker Architecture
(CORBA)&#XA0;[<A HREF="#corba26-spec">OMG01</A>] specification. Where possible, backward
compatibility has been maintained back to specification 2.0. It passed
the Open Group CORBA compliant testsuite (for CORBA 2.1) and was one
of the three ORBs to be granted the CORBA brand in June
1999<SUP><A NAME="text1" HREF="#note1">1</A></SUP>.</P><P>This user guide tells you how to use omniORB to develop CORBA
applications. It assumes a basic understanding of CORBA.</P><P>In this chapter, we give an overview of the main features of omniORB
and what you need to do to set up your environment to run omniORB.</P><!--TOC section Features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;Features</H2><!--SEC END --><P>omniORB is quite feature-rich, but it does not slavishly implement
every last part of the CORBA specification. The goal is to provide the
most generally useful parts of the specification in a clean and
efficient manner. Highlights are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">C++ and Python language bindings.</LI><LI CLASS="li-itemize">Support for the complete Portable Object Adapter (POA) specification.</LI><LI CLASS="li-itemize">Support for the Interoperable Naming Service (INS).</LI><LI CLASS="li-itemize">Internet Inter-ORB Protocol (IIOP 1.2) is used as the native
protocol.</LI><LI CLASS="li-itemize">The omniORB runtime is fully multithreaded. It uses platform
thread support encapsulated with a small class library, omnithread,
to abstract away from differences in native thread APIs.</LI><LI CLASS="li-itemize">TypeCode and type Any are supported.</LI><LI CLASS="li-itemize">DynAny is supported.</LI><LI CLASS="li-itemize">The Dynamic Invocation and Dynamic Skeleton interfaces are supported.</LI><LI CLASS="li-itemize">Valuetype and abstract interfaces are supported.</LI><LI CLASS="li-itemize">Asynchronous Method Invocation (AMI) supported, including both
polling and callback models.</LI><LI CLASS="li-itemize">Extensive control over connection management.</LI><LI CLASS="li-itemize">Soft real-time features including call deadlines and timeouts.</LI><LI CLASS="li-itemize">A COS Naming Service, omniNames.</LI><LI CLASS="li-itemize">Many platforms are supported, including most Unix platforms and
Windows.</LI><LI CLASS="li-itemize">It has been successfully tested for interoperability via IIOP with
other ORBs.</LI></UL><!--TOC subsection Multithreading-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">1.1.1</A>&#XA0;&#XA0;Multithreading</H3><!--SEC END --><P>omniORB is fully multithreaded. To achieve low call overhead,
unnecessary call multiplexing is eliminated. With the default
policies, there is at most one call in-flight in each communication
channel between two address spaces at any one time. To do this without
limiting the level of concurrency, new channels connecting the two
address spaces are created on demand and cached when there are
concurrent calls in progress. Each channel is served by a dedicated
thread. This arrangement provides maximal concurrency and eliminates
any thread switching in either of the address spaces to process a
call. Furthermore, to maximise the throughput in processing large call
arguments, large data elements are sent as soon as they are processed
while the other arguments are being marshalled. With GIOP 1.2, large
messages are fragmented, so the marshaller can start transmission
before it knows how large the entire message will be.</P><P>omniORB also supports a flexible thread pool policy, and supports
sending multiple interleaved calls on a single connection. This policy
leads to a small amount of additional call overhead, compared to the
default thread per connection model, but allows omniORB to scale to
extremely large numbers of concurrent clients.</P><!--TOC subsection Portability-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">1.1.2</A>&#XA0;&#XA0;Portability</H3><!--SEC END --><P>omniORB runs on many flavours of Unix, Windows, several embedded
operating systems, and relatively obscure systems such as OpenVMS and
Fujitsu-Siemens BS2000. It is designed to be easy to port to new
platforms. The IDL to C++ mapping for all target platforms is the
same.</P><P>omniORB uses real C++ exceptions and nested classes. It keeps to the
CORBA specification&#X2019;s standard mapping as much as possible and does
not use the alternative mappings for C++ dialects. The only small
exception is the mapping of IDL modules, which can use either
namespaces according to the standard, or nested classes for truly
ancient C++ compilers without namespace support.</P><P>omniORB relies on native thread libraries to provide multithreading
capability. A small class library (omnithread&#XA0;[<A HREF="#tjr96a">Ric96</A>]) is used
to encapsulate the APIs of the native thread libraries. In application
code, it is recommended but not mandatory to use this class library
for thread management. It should be easy to port omnithread to any
platform that either supports the POSIX thread standard or has a
thread package that supports similar capabilities.</P><P>Partly for historical reasons, and partly to support users with
archaic compilers, omniORB does not use the C++ standard library.</P><P>The omniORB IDL compiler, omniidl, requires Python 2.5, 2.6 or 2.7.</P><!--TOC subsection Missing features-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">1.1.3</A>&#XA0;&#XA0;Missing features</H3><!--SEC END --><P>
<A NAME="sec:missing"></A></P><P>omniORB is not a complete implementation of the CORBA 2.6 core. The
following is a list of the most significant missing features.</P><UL CLASS="itemize"><LI CLASS="li-itemize">omniORB does not have its own Interface Repository. However, it
can act as a client to an IfR. The omniifr project
(<A HREF="http://omniifr.sourceforge.net/"><TT>http://omniifr.sourceforge.net/</TT></A>) aims to create an IfR for
omniORB.</LI><LI CLASS="li-itemize">omniORB supports interceptors, but not the standard Portable
Interceptor API.</LI></UL><!--TOC section Setting up your environment-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.2</A>&#XA0;&#XA0;Setting up your environment</H2><!--SEC END --><P>
<A NAME="sec:setup"></A></P><P>To get omniORB running, you first need to install omniORB according to
the instructions in the installation notes for your platform. See
<TT>README.FIRST.txt</TT> at the top of the omniORB tree for
instructions. Most Unix platforms can use the Autoconf
<TT>configure</TT> script to automate the configuration process.</P><P>Once omniORB is installed in a suitable location, you must configure
it according to your required setup. The configuration can be set with
a configuration file, environment variables, command-line arguments
or, on Windows, the Windows registry.</P><UL CLASS="itemize"><LI CLASS="li-itemize">On Unix platforms, the omniORB runtime looks for the environment
variable <TT>OMNIORB_CONFIG</TT>. If this variable is defined, it
contains the pathname of the omniORB configuration file. If the
variable is not set, omniORB will use the compiled-in pathname to
locate the file (by default <TT>/etc/omniORB.cfg</TT>).</LI><LI CLASS="li-itemize">On Win32 / Win64 platforms, omniORB first checks the environment
variable <TT>OMNIORB_CONFIG</TT> to obtain the pathname of the
configuration file. If this is not set, it then attempts to obtain
configuration data in the system registry. It searches for the data
under the key <TT>HKEY_LOCAL_MACHINE\SOFTWARE\omniORB</TT>.</LI></UL><P>omniORB has a large number of parameters than can be configured. See
chapter&#XA0;<A HREF="#chap:config">4</A> for full details. The files
<TT>sample.cfg</TT> and <TT>sample.reg</TT> contain an example
configuration file and set of registry entries respectively.</P><P>To get all the omniORB examples running, the main thing you need to
configure is the Naming service, omniNames. To do that, the
configuration file or registry should contain an entry of the form</P><PRE CLASS="verbatim">  InitRef = NameService=corbaname::my.host.name
</PRE><P>See section&#XA0;<A HREF="#sec:corbaname">7.1.4</A> for full details of
corbaname URIs.</P><!--TOC section Platform specific variables-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">1.3</A>&#XA0;&#XA0;Platform specific variables</H2><!--SEC END --><P>To compile omniORB programs correctly, several C++ preprocessor
defines <EM>must</EM> be specified to identify the target platform. On
Unix platforms where omniORB was configured with Autoconf, the
<TT>omniconfig.h</TT> file sets these for you. On other platforms, and
Unix platforms when Autoconf is not used, you must specify the
following defines:</P><DIV CLASS="flushleft">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>Platform</TD><TD ALIGN=left NOWRAP>CPP defines</TD></TR>
<TR><TD ALIGN=left NOWRAP>Windows</TD><TD ALIGN=left NOWRAP><CODE>__x86__     __NT__       __OSVERSION__=4  __WIN32__</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Windows NT 3.5</TD><TD ALIGN=left NOWRAP><CODE>__x86__     __NT__       __OSVERSION__=3  __WIN32__</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Sun Solaris 2.5</TD><TD ALIGN=left NOWRAP><CODE>__sparc__   __sunos__    __OSVERSION__=5</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
HPUX 10.x</TD><TD ALIGN=left NOWRAP><CODE>__hppa__    __hpux__     __OSVERSION__=10</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
HPUX 11.x</TD><TD ALIGN=left NOWRAP><CODE>__hppa__    __hpux__     __OSVERSION__=11</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
IBM AIX 4.x</TD><TD ALIGN=left NOWRAP><CODE>__aix__     __powerpc__  __OSVERSION__=4</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Digital Unix 3.2</TD><TD ALIGN=left NOWRAP><CODE>__alpha__   __osf1__     __OSVERSION__=3</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Linux 2.x (x86)</TD><TD ALIGN=left NOWRAP><CODE>__x86__     __linux__    __OSVERSION__=2</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Linux 2.x (powerpc)</TD><TD ALIGN=left NOWRAP><CODE>__powerpc__ __linux__    __OSVERSION__=2</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
OpenVMS 6.x (alpha)</TD><TD ALIGN=left NOWRAP><CODE>__alpha__   __vms        __OSVERSION__=6 </CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
OpenVMS 6.x (vax)</TD><TD ALIGN=left NOWRAP><CODE>__vax__     __vms        __OSVERSION__=6 </CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
SGI Irix 6.x</TD><TD ALIGN=left NOWRAP><CODE>__mips__    __irix__     __OSVERSION__=6 </CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Reliant Unix 5.43</TD><TD ALIGN=left NOWRAP><CODE>__mips__    __SINIX__    __OSVERSION__=5 </CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
ATMos 4.0</TD><TD ALIGN=left NOWRAP><CODE>__arm__     __atmos__    __OSVERSION__=4</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
NextStep 3.x</TD><TD ALIGN=left NOWRAP><CODE>__m68k__    __nextstep__ __OSVERSION__=3</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>
Unixware 7</TD><TD ALIGN=left NOWRAP><CODE>__x86__     __uw7__      __OSVERSION__=5</CODE></TD></TR>
</TABLE>
</DIV><P>The preprocessor defines for new platform ports not listed above can
be found in the corresponding platform configuration files. For
instance, the platform configuration file for Sun Solaris 2.6 is in
<TT>mk/platforms/sun4_sosV_5.6.mk</TT>. The preprocessor defines to
identify a platform are in the make variable
<TT>IMPORT_CPPFLAGS</TT>.</P><P>In a single source multi-target environment, you can put the
preprocessor defines as the command-line arguments for the compiler.
If you are building for a single platform, you can edit
include/omniconfig.h to add the definitions.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">More information can be found at
<A HREF="http://www.opengroup.org/press/7jun99_b.htm"><TT>http://www.opengroup.org/press/7jun99_b.htm</TT></A>
</DD></DL>
<!--END NOTES-->
<!--TOC chapter The Basics-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc8">Chapter&#XA0;2</A>&#XA0;&#XA0;The Basics</H1><!--SEC END --><P>
<A NAME="chap:basic"></A></P><P>In this chapter, we go through three examples to illustrate the
practical steps to use omniORB. By going through the source code of
each example, the essential concepts and APIs are introduced. If you
have no previous experience with using CORBA, you should study this
chapter in detail. There are pointers to other essential documents you
should be familiar with.</P><P>If you have experience with using other ORBs, you should still go
through this chapter because it provides important information about
the features and APIs that are necessarily omniORB specific. With the
Portable Object Adapter, there are very few omniORB specific details.</P><!--TOC section The Echo Object Example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">2.1</A>&#XA0;&#XA0;The Echo Object Example</H2><!--SEC END --><P>Our example is an object which has only one method. The method simply
echos the argument string. We have to:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">define the object interface in IDL
</LI><LI CLASS="li-enumerate">use the IDL compiler to generate the stub code, which provides
the object mapping as defined in the CORBA specification
</LI><LI CLASS="li-enumerate">provide the <I>servant</I> object implementation
</LI><LI CLASS="li-enumerate">write the client code.</LI></OL><P>These examples are in the <TT>src/examples/echo</TT> directory of the
omniORB distribution; there are several other examples in
<TT>src/examples</TT>.</P><!--TOC section Specifying the Echo interface in IDL-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">2.2</A>&#XA0;&#XA0;Specifying the Echo interface in IDL</H2><!--SEC END --><P>We define an object interface, called <TT>Echo</TT>, as follows:</P><DIV CLASS="lstlisting"><B>interface</B> Echo {
  <B>string</B> echoString(<B>in</B> <B>string</B> mesg);
};</DIV><P>If you are new to IDL, you can learn about its syntax in Chapter 3 of
the CORBA 2.6 specification&#XA0;[<A HREF="#corba26-spec">OMG01</A>]. For the moment, you
only need to know that the interface consists of a single operation,
<TT>echoString()</TT>, which takes a string as an input argument and returns
a copy of the same string.</P><P>The interface is written in a file, called <TT>echo.idl</TT>. It is part
of the CORBA standard that all IDL files must have the extension
&#X2018;<TT>.idl</TT>&#X2019;, although omniORB does not enforce this. In the omniORB
distribution, this file is in <TT>idl/echo.idl</TT>.</P><P>For simplicity, the interface is defined in the global IDL namespace.
You should normally avoid this practice for the sake of object
reusability. If every CORBA developer defines their interfaces in the
global IDL namespace, there is a danger of name clashes between two
independently defined interfaces. Therefore, it is better to qualify
your interfaces by defining them inside <TT>module</TT> names. Of
course, this does not eliminate the chance of a name clash unless some
form of naming convention is agreed globally. Nevertheless, a
well-chosen module name can help a lot.</P><!--TOC section Generating the C++ stubs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">2.3</A>&#XA0;&#XA0;Generating the C++ stubs</H2><!--SEC END --><P>From the IDL file, we use the IDL compiler to produce the C++ mapping
of the interface. The IDL compiler for omniORB is called omniidl.
Given the IDL file, omniidl produces two stub files: a C++ header file
and a C++ source file. For example, from the file <TT>echo.idl</TT>, the
following files are produced:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>echo.hh</TT>
</LI><LI CLASS="li-itemize"><TT>echoSK.cc</TT>
</LI></UL><P>omniidl must be invoked with the <TT>-bcxx</TT> argument to
tell it to generate C++ stubs. The following command line generates
the stubs for <TT>echo.idl</TT>:</P><DIV CLASS="lstlisting">omniidl -bcxx echo.idl</DIV><P>Note that the names <TT>echo.hh</TT> and <TT>echoSK.cc</TT> are not
defined in the C++ mapping standard. Other CORBA implementations may
use different file names. To aid migration omniidl from other
implementations, omniidl has options to override the default output
file names. See section&#XA0;<A HREF="#sec:cxx_backend">5.2</A> for details.</P><P>If you are using our make environment, you don&#X2019;t need to invoke
omniidl explicitly. In the example file <TT>dir.mk</TT>, we have the
following line:</P><DIV CLASS="lstlisting">CORBA_INTERFACES = echo</DIV><P>That is all we need to instruct the build system to generate
the stubs. You won&#X2019;t find the stubs in your working directory because
all stubs are written into the <TT>stub</TT> directory at the top level
of your build tree.</P><P>The full arguments to omniidl are detailed in
chapter&#XA0;<A HREF="#chap:omniidl">5</A>.</P><!--TOC section Object References and Servants-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc12">2.4</A>&#XA0;&#XA0;Object References and Servants</H2><!--SEC END --><P>We contact a CORBA object through an <I>object reference</I>. The
actual implementation of a CORBA object is termed a <I>servant</I>.</P><P>Object references and servants are quite separate entities, and it is
important not to confuse the two. Client code deals purely with object
references, so there can be no confusion; object implementation code
must deal with both object references and servants. omniORB uses
distinct C++ types for object references and servants, so the C++
compiler will complain if you use a servant when an object reference
is expected, or vice-versa.</P><!--TOC section A quick look at the C++ mapping-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc13">2.5</A>&#XA0;&#XA0;A quick look at the C++ mapping</H2><!--SEC END --><P>The C++ stubs conform to the standard mapping defined in the CORBA
specification&#XA0;[<A HREF="#cxxmapping">OMG03</A>]. Sadly, since it pre-dates the C++
standard library, the C++ language mapping is quite hard to use,
especially because it has complex memory management rules.</P><P>The best way to understand the mapping is to read either the
specification or, better, a book about using CORBA from C++. Reading
the code generated by omniidl is hard-going, and it is difficult to
distinguish the parts you need to know from the implementation
details.</P><!--TOC subsection Mapping overview-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">2.5.1</A>&#XA0;&#XA0;Mapping overview</H3><!--SEC END --><P>For interface <TT>Echo</TT>, omniidl generates four things of note:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
class <TT>Echo</TT>, containing static functions and type
definitions</LI><LI CLASS="li-itemize"><TT>Echo_ptr</TT>, an <EM>object reference</EM> type with pointer
semantics</LI><LI CLASS="li-itemize"><TT>Echo_var</TT>, a memory management helper for
<TT>Echo_ptr</TT></LI><LI CLASS="li-itemize">class <TT>POA_Echo</TT>, the server-side <EM>skeleton</EM> class</LI></UL><!--TOC subsection Interface scope type-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">2.5.2</A>&#XA0;&#XA0;Interface scope type</H3><!--SEC END --><P>A C++ class <TT>Echo</TT> is defined to hold a number of static
functions and type definitions. It looks like this:</P><DIV CLASS="lstlisting"><B>class</B> Echo {
<B>public</B>:
  <B>typedef</B> Echo_ptr _ptr_type;
  <B>typedef</B> Echo_var _var_type;

  <B>static</B> _ptr_type _duplicate(_ptr_type);
  <B>static</B> _ptr_type _narrow(CORBA::Object_ptr);
  <B>static</B> _ptr_type _nil();
};</DIV><P>The <TT>_ptr_type</TT> and <TT>_var_type</TT> typedefs are there to
facilitate template programming. The static functions are described
below.</P><!--TOC subsection Object reference pointer type-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">2.5.3</A>&#XA0;&#XA0;Object reference pointer type</H3><!--SEC END --><P>For interface <TT>Echo</TT>, the mapping defines the object reference
type <TT>Echo_ptr</TT> which has pointer semantics. The <TT>_ptr</TT>
type provides access to the interface&#X2019;s operations. The concrete type
of an object reference is opaque, i.e. you must not make any
assumptions about how an object reference is implemented. You can
imagine it looks something like this:</P><DIV CLASS="lstlisting"><B>class</B> <I>private_class</I> : <B>public</B> <I>some_base_class</I> {
  <B>char</B>* echoString(<B>const</B> <B>char</B>* mesg);
};

<B>typedef</B> <I>something</I> Echo_ptr;</DIV><P>To use an object reference, you use the arrow operator &#X2018;<TT>-&gt;</TT>&#X2019; to
invoke its operations, but you must not use it as a C++ pointer in any
other respect. It is non-compliant to convert it to <TT>void*</TT>,
perform arithmetic or relational operations including testing for
equality using <TT>operator==</TT>.</P><P>In some CORBA implementations, <TT>Echo_ptr</TT> is a typedef to
<TT>Echo*</TT>. In omniORB, it is not&#X2014;the object reference type is
distinct from class <TT>Echo</TT>.</P><!--TOC subsubsection Nil object reference-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc17">2.5.3.1</A>&#XA0;&#XA0;Nil object reference</H4><!--SEC END --><P>Object references can be <EM>nil</EM>. To obtain a nil object reference
for interface <TT>Echo</TT>, call <TT>Echo::_nil()</TT>. To test if an
object reference is nil, use <TT>CORBA::_is_nil()</TT>:</P><DIV CLASS="lstlisting">CORBA::Boolean true_result = CORBA::is_nil(Echo::_nil());</DIV><P><TT>Echo::_nil()</TT> is the only compliant way to obtain a nil Echo
reference, and <TT>CORBA::is_nil()</TT> is the only compliant way to check
if an object reference is nil. You should not use the equality
<TT>operator==</TT>. Many C++ ORBs use the null pointer to represent a
nil object reference, but <EM>omniORB does not</EM>.</P><!--TOC subsubsection Object reference lifecycle-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc18">2.5.3.2</A>&#XA0;&#XA0;Object reference lifecycle</H4><!--SEC END --><P>Object references are reference counted. That is, the opaque C++
objects on the client side that implement <TT>Echo_ptr</TT> are
reference counted, so they are deleted when the count goes to zero.
The lifetime of an object reference has no bearing at all on the
lifetime of the CORBA object to which it is a reference&#X2014;when an
object reference is deleted, it has <EM>no effect</EM> on the object in
the server.</P><P>Reference counting for <TT>Echo</TT> object references is performed with
<TT>Echo::_duplicate()</TT> and <TT>CORBA::release()</TT>.</P><P>The <TT>_duplicate()</TT> function returns a new object reference of the
Echo interface. The new object reference can be used interchangeably
with the old object reference to perform an operation on the same
object.</P><P>To indicate that an object reference will no longer be accessed, you
must call the <TT>CORBA::release()</TT> operation. Its signature is as
follows:</P><DIV CLASS="lstlisting"><B>namespace</B> CORBA {
  <B>void</B> release(CORBA::Object_ptr obj);
  ... <I>// other methods</I>
};</DIV><P>Once you have called <TT>CORBA::release()</TT> on an object reference, you
may no longer use that reference. This is because the associated
resources may have been deallocated. Remember that we are referring to
the resources associated with the object reference and <EM>not the
servant object</EM>. Servant objects are not affected by the lifetimes
of object references. In particular, servants are not deleted when all
references to them have been released&#X2014;CORBA does not perform
distributed garbage collection.</P><P>Nil object references are <EM>not</EM> reference counted, so there is no
need to call <TT>_duplicate()</TT> and <TT>release()</TT> with them, although it
does no harm.</P><P>Since object references must be released explicitly, their usage is
prone to error and can lead to memory leaks or invalid memory
accesses. The mapping defines the <I>object reference variable</I>
type <TT>Echo_var</TT> to make life somewhat easier.</P><P>The <TT>Echo_var</TT> is more convenient to use because it
automatically releases its object reference when it goes out of scope
or when assigned a new object reference. For many operations, mixing
data of type <TT>Echo_var</TT> and <TT>Echo_ptr</TT> is possible without
any explicit operations or casting. For instance, the <TT>echoString()</TT>
operation can be called using the arrow (&#X2018;<TT>-&gt;</TT>&#X2019;) on a
<TT>Echo_var</TT>, as one can do with a <TT>Echo_ptr</TT>.</P><P>The usage of <TT>Echo_var</TT> is illustrated below:</P><DIV CLASS="lstlisting">Echo_var a;
Echo_ptr p = ... <I>// somehow obtain an object reference</I>

a = p;           <I>// a assumes ownership of p, must not use p any more</I>

Echo_var b = a;  <I>// implicit _duplicate</I>

p = ...          <I>// somehow obtain another object reference</I>

a = Echo::_duplicate(p);     <I>// release old object reference</I>
                             <I>// a now holds a copy of p.</I></DIV><P>The mappings of many other IDL data types include <TT>_var</TT> types
with similar semantics.</P><!--TOC subsubsection Object reference inheritance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc19">2.5.3.3</A>&#XA0;&#XA0;Object reference inheritance</H4><!--SEC END --><P>All CORBA objects inherit from the generic object
<TT>CORBA::Object</TT>. <TT>CORBA::Object_ptr</TT> is the object
reference type for base <TT>CORBA::Object</TT>. Object references can be
implicitly <EM>widened</EM> to base interface types, so this is valid:</P><DIV CLASS="lstlisting">Echo_ptr echo_ref = <I>// get reference from somewhere</I>
CORBA::Object_ptr base_ref = echo_ref; <I>// widen</I></DIV><P>An object reference such as <TT>Echo_ptr</TT> can be used in places
where a <TT>CORBA::Object_ptr</TT> is expected. Conversely, the
<TT>Echo::_narrow()</TT> function takes an argument of type
<TT>CORBA::Object_ptr</TT> and returns a new object reference of the
<TT>Echo</TT> interface. If the actual (runtime) type of the argument
object reference can be narrowed to <TT>Echo_ptr</TT>, <TT>_narrow()</TT>
will return a valid object reference. Otherwise it will return a nil
object reference. Note that <TT>_narrow()</TT> performs an implicit
duplication of the object reference, so the result must be released.
Note also that <TT>_narrow()</TT> may involve a remote call to check the
type of the object, so it may throw CORBA system exceptions such as
<TT>TRANSIENT</TT> or <TT>OBJECT_NOT_EXIST</TT>.</P><!--TOC subsubsection Object reference equivalence-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc20">2.5.3.4</A>&#XA0;&#XA0;Object reference equivalence</H4><!--SEC END --><P>As described above, the equality <TT>operator==</TT> should not be used
on object references. To test if two object references are equivalent,
the member function <TT>_is_equivalent()</TT> of the generic object
<TT>CORBA::Object</TT> can be used. Here is an example of its usage:</P><DIV CLASS="lstlisting">Echo_ptr a;
...            <I>// initialise a to a valid object reference </I>
Echo_ptr b = a;
CORBA::Boolean true_result = a-&gt;_is_equivalent(a);
<I>// Note: the above call is guaranteed to be true</I></DIV><P><TT>_is_equivalent()</TT> does <EM>not</EM> contact the object to check for
equivalence&#X2014;it uses purely local knowledge, meaning that it is
possible to construct situations in which two object references refer
to the same object, but <TT>_is_equivalent()</TT> does not consider them
equivalent. If you need a strong sense of object identity, you must
implement it with explicit IDL operations.</P><!--TOC subsection Servant Object Implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">2.5.4</A>&#XA0;&#XA0;Servant Object Implementation</H3><!--SEC END --><P>
<A NAME="stubobjimpl"></A></P><P>For each object interface, a <I>skeleton</I> class is generated. In
our example, the POA specification says that the skeleton class for
interface <TT>Echo</TT> is named <TT>POA_Echo</TT>. A servant
implementation can be written by creating an implementation class that
derives from the skeleton class.</P><P>The skeleton class <TT>POA_Echo</TT> is defined in <TT>echo.hh</TT>. The
relevant section of the code is reproduced below.</P><DIV CLASS="lstlisting"><B>class</B> POA_Echo :
  <B>public</B> <B>virtual</B> PortableServer::ServantBase
{
<B>public</B>:
  Echo_ptr _this();

  <B>virtual</B> <B>char</B> * echoString(<B>const</B> <B>char</B>* mesg) = 0;
};</DIV><P>The code fragment shows the only member functions that can be used in
the object implementation code. Other member functions are generated
for internal use only. As with the code generated for object
references, other POA-based ORBs will generate code which looks
different, but is functionally equivalent to this.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>echoString()</TT></B></DT><DD CLASS="dd-description"><BR>
It is through this abstract function that an implementation class
provides the implementation of the <TT>echoString()</TT> operation. Notice
that its signature is the same as the <TT>echoString()</TT> function that
can be invoked via the <TT>Echo_ptr</TT> object reference. This will be
the case most of the time, but object reference operations for certain
parameter types use special helper classes to facilitate correct
memory management.</DD><DT CLASS="dt-description"><B><TT>_this()</TT></B></DT><DD CLASS="dd-description"><BR>
The <TT>_this()</TT> function returns an object reference for the target
object, provided the POA policies permit it. The returned value must
be deallocated via <TT>CORBA::release()</TT>. See
section&#XA0;<A HREF="#objeg1">2.8</A> for an example of how this function is used.</DD></DL><!--TOC section Writing the servant implementation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">2.6</A>&#XA0;&#XA0;Writing the servant implementation</H2><!--SEC END --><P>
<A NAME="objimpl"></A></P><P>You define a class to provide the servant implementation. There is
little constraint on how you design your implementation class except
that it has to inherit from the skeleton class<SUP><A NAME="text2" HREF="#note2">1</A></SUP> and to
implement all the abstract functions defined in the skeleton
class. Each of these abstract functions corresponds to an operation of
the interface. They are the hooks for the ORB to perform upcalls to
your implementation. Here is a simple implementation of the Echo
object.</P><DIV CLASS="lstlisting"><B>class</B> Echo_i : <B>public</B> POA_Echo
{
<B>public</B>:
  <B>inline</B> Echo_i() {}
  <B>virtual</B> ~Echo_i() {}
  <B>virtual</B> <B>char</B>* echoString(<B>const</B> <B>char</B>* mesg);
};

<B>char</B>* Echo_i::echoString(<B>const</B> <B>char</B>* mesg)
{
  <B>return</B> CORBA::string_dup(mesg);
}</DIV><P>There are four points to note here:</P><DL CLASS="description"><DT CLASS="dt-description"><B>Storage Responsibilities</B></DT><DD CLASS="dd-description"><BR>
String, which is used both as an in argument and the return value of
<TT>echoString()</TT>, is a variable sized data type. Other examples of
variable sized data types include sequences, type &#X2018;any&#X2019;, etc. For
these data types, you must be clear about whose responsibility it is
to allocate and release the associated storage. As a rule of thumb,
the client (or the caller to the implementation functions) owns the
storage of all <EM>in</EM> arguments, the object implementation (or the
callee) must copy the data if it wants to retain a copy. For
<EM>out</EM> arguments and return values, the object implementation
allocates the storage and passes the ownership to the client. The
client must release the storage when the variables will no longer be
used. For details, see the C++ mapping specification.</DD><DT CLASS="dt-description"><B>Multi-threading</B></DT><DD CLASS="dd-description"><BR>
As omniORB is fully multithreaded, multiple threads may perform the
same upcall to your implementation concurrently. It is up to your
implementation to synchronise the threads&#X2019; accesses to shared data.
In our simple example, we have no shared data to protect so no thread
synchronisation is necessary.<P>Alternatively, you can create a POA which has the
<TT>SINGLE_THREAD_MODEL</TT> Thread Policy. This guarantees that all
calls to that POA are processed sequentially.</P></DD><DT CLASS="dt-description"><B>Reference Counting</B></DT><DD CLASS="dd-description"><BR>
All servant objects are reference counted. The base
<TT>PortableServer::ServantBase</TT> class from which all servant
skeleton classes derive defines member functions named <TT>_add_ref()</TT>
and <TT>_remove_ref()</TT><SUP><A NAME="text3" HREF="#note3">2</A></SUP>. The reference
counting means that an <TT>Echo_i</TT> instance will be deleted when no
more references to it are held by application code or the POA
itself. Note that this is totally separate from the reference counting
which is associated with object references&#X2014;a servant object is
<EM>never</EM> deleted due to a CORBA object reference being released.</DD><DT CLASS="dt-description"><B>Instantiation</B></DT><DD CLASS="dd-description"><BR>
Servants are usually instantiated on the heap, i.e. using the
<TT>new</TT> operator. However, they can also be created on the stack as
automatic variables. If you do that, it is vital to make sure that the
servant has been deactivated, and thus released by the POA, before the
variable goes out of scope and is destroyed.</DD></DL><!--TOC section Writing the client-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">2.7</A>&#XA0;&#XA0;Writing the client</H2><!--SEC END --><P>Here is an example of how an <TT>Echo_ptr</TT> object reference is
used.</P><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <B>void</B>
<FONT SIZE=1>   2</FONT> hello(CORBA::Object_ptr obj)
<FONT SIZE=1>   3</FONT> {
<FONT SIZE=1>   4</FONT>   Echo_var e = Echo::_narrow(obj);
<FONT SIZE=1>   5</FONT> 
<FONT SIZE=1>   6</FONT>   <B>if</B> (CORBA::is_nil(e)) {
<FONT SIZE=1>   7</FONT>     cerr &lt;&lt; "cannot invoke on a nil object reference."
<FONT SIZE=1>   8</FONT>          &lt;&lt; endl;
<FONT SIZE=1>   9</FONT>     <B>return</B>;
<FONT SIZE=1>  10</FONT>   }
<FONT SIZE=1>  11</FONT> 
<FONT SIZE=1>  12</FONT>   CORBA::String_var src = (<B>const</B> <B>char</B>*) "Hello!";
<FONT SIZE=1>  13</FONT>   CORBA::String_var dest;
<FONT SIZE=1>  14</FONT> 
<FONT SIZE=1>  15</FONT>   dest = e-&gt;echoString(src);
<FONT SIZE=1>  16</FONT> 
<FONT SIZE=1>  17</FONT>   cout &lt;&lt; "I said,\"" &lt;&lt; src &lt;&lt; "\"."
<FONT SIZE=1>  18</FONT>        &lt;&lt; " The Object said,\"" &lt;&lt; dest &lt;&lt;"\"" &lt;&lt; endl;
<FONT SIZE=1>  19</FONT> }</DIV><P>The <TT>hello()</TT> function accepts a generic object reference. The
object reference (<TT>obj</TT>) is narrowed to <TT>Echo_ptr</TT>. If the
object reference returned by <TT>Echo::_narrow()</TT> is not nil, the
operation <TT>echoString()</TT> is invoked. Finally, both the argument to
and the return value of <TT>echoString()</TT> are printed to <TT>cout</TT>.</P><P>The example also illustrates how <TT>T_var</TT> types are used. As was
explained in the previous section, <TT>T_var</TT> types take care of
storage allocation and release automatically when variables are
reassigned or when the variables go out of scope.</P><P>In line 4, the variable <TT>e</TT> takes over the storage responsibility
of the object reference returned by <TT>Echo::_narrow()</TT>. The object
reference is released by the destructor of <TT>e</TT>. It is called
automatically when the function returns. Lines 6 and 15 show how a
<TT>Echo_var</TT> variable is used. As explained earlier, the
<TT>Echo_var</TT> type can be used interchangeably with the
<TT>Echo_ptr</TT> type.</P><P>The argument and the return value of <TT>echoString()</TT> are stored in
<TT>CORBA::String_var</TT> variables <TT>src</TT> and <TT>dest</TT>
respectively. The strings managed by the variables are deallocated by
the destructor of <TT>CORBA::String_var</TT>. It is called
automatically when the variable goes out of scope (as the function
returns). Line 15 shows how <TT>CORBA::String_var</TT> variables are
used. They can be used in place of a string (for which the mapping is
<TT>char*</TT>)<SUP><A NAME="text4" HREF="#note4">3</A></SUP>. As used in line 12, assigning a constant string
(<TT>const char*</TT>) to a <TT>CORBA::String_var</TT> causes the string
to be copied. On the other hand, assigning a <TT>char*</TT> to a
<TT>CORBA::String_var</TT>, as used in line 15, causes the latter to
assume the ownership of the string<SUP><A NAME="text5" HREF="#note5">4</A></SUP>.</P><P>Under the C++ mapping, <TT>T_var</TT> types are provided for all the
non-basic data types. One should use automatic variables whenever
possible both to avoid memory leaks and to maximise performance.
However, when one has to allocate data items on the heap, it is a good
practice to use the <TT>T_var</TT> types to manage the heap storage.</P><!--TOC section Example 1 &#X2014; Colocated Client and Servant-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">2.8</A>&#XA0;&#XA0;Example 1 &#X2014; Colocated Client and Servant</H2><!--SEC END --><P>
<A NAME="objeg1"></A></P><P>Having introduced the client and the object implementation, we can now
describe how to link up the two via the ORB and POA. In this section,
we describe an example in which both the client and the object
implementation are in the same address space. In the next two
sections, we shall describe the case where the two are in different
address spaces.</P><P>The code for this example is reproduced below:</P><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <B>int</B>
<FONT SIZE=1>   2</FONT> main(<B>int</B> argc, <B>char</B> **argv)
<FONT SIZE=1>   3</FONT> {
<FONT SIZE=1>   4</FONT>   CORBA::ORB_ptr orb = CORBA::ORB_init(argc, argv, "omniORB4");
<FONT SIZE=1>   5</FONT> 
<FONT SIZE=1>   6</FONT>   CORBA::Object_var       obj = orb-&gt;resolve_initial_references("RootPOA");
<FONT SIZE=1>   7</FONT>   PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
<FONT SIZE=1>   8</FONT> 
<FONT SIZE=1>   9</FONT>   PortableServer::Servant_var&lt;Echo_i&gt; myecho = <B>new</B> Echo_i();
<FONT SIZE=1>  10</FONT>   PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(myecho);
<FONT SIZE=1>  11</FONT> 
<FONT SIZE=1>  12</FONT>   Echo_var myechoref = myecho-&gt;_this();
<FONT SIZE=1>  13</FONT> 
<FONT SIZE=1>  14</FONT>   PortableServer::POAManager_var pman = poa-&gt;the_POAManager();
<FONT SIZE=1>  15</FONT>   pman-&gt;activate();
<FONT SIZE=1>  16</FONT> 
<FONT SIZE=1>  17</FONT>   hello(myechoref);
<FONT SIZE=1>  18</FONT> 
<FONT SIZE=1>  19</FONT>   orb-&gt;destroy();
<FONT SIZE=1>  20</FONT>   <B>return</B> 0;
<FONT SIZE=1>  21</FONT> }</DIV><P>The example illustrates several important interactions among the ORB,
the POA, the servant, and the client. Here are the details:</P><!--TOC subsection ORB initialisation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">2.8.1</A>&#XA0;&#XA0;ORB initialisation</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 4</B></DT><DD CLASS="dd-description"><BR>
The ORB is initialised by calling the <TT>CORBA::ORB_init()</TT>
function. The function uses the optional 3rd argument to determine
which ORB should be returned. Unless you are using omniORB specific
features, it is usually best to leave it out, and get the default
ORB. To explicitly ask for omniORB 4.x, this argument must be
&#X2018;omniORB4&#X2019;<SUP><A NAME="text6" HREF="#note6">5</A></SUP>.<P><TT>CORBA::ORB_init()</TT> takes the list of command line arguments and
processes any that start &#X2018;<TT>-ORB</TT>&#X2019;. It removes these arguments
from the list, so application code does not have to deal with them.</P><P>If any error occurs during ORB initialisation, such as invalid ORB
arguments, or an invalid configuration file, the
<TT>CORBA::INITIALIZE</TT> system exception is raised.</P></DD></DL><!--TOC subsection Obtaining the Root POA-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">2.8.2</A>&#XA0;&#XA0;Obtaining the Root POA</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Lines 6&#X2013;7</B></DT><DD CLASS="dd-description"><BR>
To activate our servant object and make it available to clients, we
must register it with a POA. In this example, we use the <I>Root
POA</I>, rather than creating any child POAs. The Root POA is found with
<TT>orb-&gt;resolve_initial_references()</TT>, which returns a plain
<TT>CORBA::Object</TT>. In line 7, we narrow the reference to the right
type for a POA.<P>A POA&#X2019;s behaviour is governed by its <I>policies</I>. The Root POA has
suitable policies for many simple servers, and closely matches the
&#X2018;policies&#X2019; used by omniORB 2&#X2019;s BOA. See Chapter 11 of the CORBA 2.6
specification[<A HREF="#corba26-spec">OMG01</A>] for details of all the POA policies
which are available.</P></DD></DL><!--TOC subsection Object initialisation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">2.8.3</A>&#XA0;&#XA0;Object initialisation</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 9</B></DT><DD CLASS="dd-description"><BR>
An instance of the Echo servant is initialised using the <TT>new</TT>
operator. The <TT>PortableServer::Servant_var&lt;&gt;</TT> template
automatically is analogous to the <TT>T_var</TT> types generated by the
IDL compiler. It releases our reference to the servant when it goes
out of scope.</DD><DT CLASS="dt-description"><B>Line 10</B></DT><DD CLASS="dd-description"><BR>
The servant object is activated in the Root POA using
<TT>poa-&gt;activate_object()</TT>, which returns an object identifier
(of type <TT>PortableServer::ObjectId*</TT>). The object id must
be passed back to various POA operations. The caller is responsible
for freeing the object id, so it is assigned to a <TT>_var</TT> type.</DD><DT CLASS="dt-description"><B>Line 12</B></DT><DD CLASS="dd-description"><BR>
The object reference is obtained from the servant object by calling
its <TT>_this()</TT> method. Like all object references, the return value
of <TT>_this()</TT> must be released by <TT>CORBA::release()</TT> when it is no
longer needed. In this case, we assign it to a <TT>_var</TT> type, so
the release is implicit at the end of the function.<P>One of the important characteristics of an object reference is that it
is completely location transparent. A client can invoke on the object
using its object reference without any need to know whether the
servant object is colocated in the same address space or is in a
different address space.</P><P>In the case of colocated client and servant, omniORB is able to
short-circuit the client calls so they do not involve IIOP. The calls
still go through the POA, however, so the various POA policies affect
local calls in the same way as remote ones. This optimisation is
applicable not only to object references returned by <TT>_this()</TT>, but
to any object references that are passed around within the same
address space or received from other address spaces via remote calls.</P></DD></DL><!--TOC subsection Activating the POA-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">2.8.4</A>&#XA0;&#XA0;Activating the POA</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Lines 15&#X2013;16</B></DT><DD CLASS="dd-description"><BR>
POAs are initially in the <I>holding</I> state, meaning that incoming
requests are blocked. Lines 15 and 16 acquire a reference to the POA&#X2019;s
POA manager, and use it to put the POA into the <I>active</I> state.
Incoming requests are now served. <B>Failing to activate the POA
is one of the most common programming mistakes. If your program
appears deadlocked, make sure you activated the POA!</B></DD></DL><!--TOC subsection Performing a call-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">2.8.5</A>&#XA0;&#XA0;Performing a call</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 18</B></DT><DD CLASS="dd-description"><BR>
At long last, we can call <TT>hello()</TT> with this object reference. The
argument is widened implicitly to the generic object reference
<TT>CORBA::Object_ptr</TT>.</DD></DL><!--TOC subsection ORB destruction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">2.8.6</A>&#XA0;&#XA0;ORB destruction</H3><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description"><B>Line 20</B></DT><DD CLASS="dd-description"><BR>
Shutdown the ORB permanently. This call causes the ORB to release all
its resources, e.g. internal threads, and also to deactivate any
servant objects which are currently active. When it deactivates the
<TT>Echo_i</TT> instance, the servant&#X2019;s reference count drops to zero,
so the servant is deleted.<P>This call is particularly important when writing a CORBA DLL on
Windows NT that is to be used from ActiveX. If this call is absent,
the application will hang when the CORBA DLL is unloaded.</P></DD></DL><!--TOC section Example 2 &#X2014; Different Address Spaces-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">2.9</A>&#XA0;&#XA0;Example 2 &#X2014; Different Address Spaces</H2><!--SEC END --><P>In this example, the client and the object implementation reside in
two different address spaces. The code of this example is almost the
same as the previous example. The only difference is the extra work
which needs to be done to pass the object reference from the object
implementation to the client.</P><P>The simplest (and quite primitive) way to pass an object reference
between two address spaces is to produce a <I>stringified</I> version
of the object reference and to pass this string to the client as a
command-line argument. The string is then converted by the client
into a proper object reference. This method is used in this
example. In the next example, we shall introduce a better way of
passing the object reference using the CORBA Naming Service.</P><!--TOC subsection Making a Stringified Object Reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">2.9.1</A>&#XA0;&#XA0;Making a Stringified Object Reference</H3><!--SEC END --><P>The <TT>main()</TT> function of the server side is reproduced below. The
full listing (<TT>eg2_impl.cc</TT>) can be found at the end of this
chapter.</P><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <B>int</B> main(<B>int</B> argc, <B>char</B>** argv)
<FONT SIZE=1>   2</FONT> {
<FONT SIZE=1>   3</FONT>   CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);
<FONT SIZE=1>   4</FONT> 
<FONT SIZE=1>   5</FONT>   CORBA::Object_var       obj = orb-&gt;resolve_initial_references("RootPOA");
<FONT SIZE=1>   6</FONT>   PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
<FONT SIZE=1>   7</FONT> 
<FONT SIZE=1>   8</FONT>   PortableServer::Servant_var&lt;Echo_i&gt; myecho = <B>new</B> Echo_i();
<FONT SIZE=1>   9</FONT> 
<FONT SIZE=1>  10</FONT>   PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(myecho);
<FONT SIZE=1>  11</FONT> 
<FONT SIZE=1>  12</FONT>   obj = myecho-&gt;_this();
<FONT SIZE=1>  13</FONT>   CORBA::String_var sior(orb-&gt;object_to_string(obj));
<FONT SIZE=1>  14</FONT>   cerr &lt;&lt; sior &lt;&lt; endl;
<FONT SIZE=1>  15</FONT> 
<FONT SIZE=1>  16</FONT>   PortableServer::POAManager_var pman = poa-&gt;the_POAManager();
<FONT SIZE=1>  17</FONT>   pman-&gt;activate();
<FONT SIZE=1>  18</FONT> 
<FONT SIZE=1>  19</FONT>   orb-&gt;run();
<FONT SIZE=1>  20</FONT>   orb-&gt;destroy();
<FONT SIZE=1>  21</FONT>   <B>return</B> 0;
<FONT SIZE=1>  22</FONT> }</DIV><P>The stringified object reference is obtained by calling the ORB&#X2019;s
<TT>object_to_string()</TT> function (line 13). This results in a
string starting with the signature &#X2018;<TT>IOR:</TT>&#X2019; and followed by quite
a lot of hexadecimal digits. All CORBA compliant ORBs are able to
convert the string into its internal representation of a so-called
Interoperable Object Reference (IOR). The IOR contains the location
information and a key to uniquely identify the object implementation
in its own address space. From the IOR, an object reference can be
constructed.</P><!--TOC subsection Client: Using a Stringified Object Reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">2.9.2</A>&#XA0;&#XA0;Client: Using a Stringified Object Reference</H3><!--SEC END --><P>
<A NAME="clnt2"></A></P><P>The stringified object reference is passed to the client as a
command-line argument. The client uses the ORB&#X2019;s
<TT>string_to_object()</TT> function to convert the string into a generic
object reference (<TT>CORBA::Object_ptr</TT>). The relevant section of
the code is reproduced below. The full listing (<TT>eg2_clt.cc</TT>) can
be found at the end of this chapter.</P><DIV CLASS="lstlisting"><B>try</B> {
  CORBA::Object_var obj = orb-&gt;string_to_object(argv[1]);
  hello(obj);
}
<B>catch</B> (CORBA::TRANSIENT&amp;) {
  ... <I>// code to handle transient exception...</I>
}</DIV><!--TOC subsection Catching System Exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">2.9.3</A>&#XA0;&#XA0;Catching System Exceptions</H3><!--SEC END --><P>When omniORB detects an error condition, it may raise a system
exception. The CORBA specification defines a series of exceptions
covering most of the error conditions that an ORB may encounter. The
client may choose to catch these exceptions and recover from the error
condition<SUP><A NAME="text7" HREF="#note7">6</A></SUP>. For instance, the code fragment, shown in
section&#XA0;<A HREF="#clnt2">2.9.2</A>, catches the <TT>TRANSIENT</TT> system exception
which indicates that the object could not be contacted at the time of
the call, usually meaning the server is not running.</P><P>All system exceptions inherit from <TT>CORBA::SystemException</TT>.
Unless you have a truly ancient C++ compiler, a single catch of
<TT>CORBA::SystemException</TT> will catch all the different system
exceptions.</P><!--TOC subsection Lifetime of a CORBA object-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">2.9.4</A>&#XA0;&#XA0;Lifetime of a CORBA object</H3><!--SEC END --><P>CORBA objects are either <I>transient</I> or <I>persistent</I>. The
majority are transient, meaning that the lifetime of the CORBA object
(as contacted through an object reference) is the same as the lifetime
of its servant object. Persistent objects can live beyond the
destruction of their servant object, the POA they were created in, and
even their process. Persistent objects are, of course, only
contactable when their associated server processes are running, and
their servants are active or can be activated by their POA with a
servant manager<SUP><A NAME="text8" HREF="#note8">7</A></SUP>. A reference to a persistent object can
be published, and will remain valid even if the server process is
restarted.</P><P>To support persistent objects, the servants must be activated in their
POA with the same object identifier each time. Also, the server must
be configured with the same <I>endpoint</I> details so it is
contactable in the same way as previous invocations. See
section&#XA0;<A HREF="#sec:endpoints">6.6</A> for details.</P><P>A POA&#X2019;s Lifespan Policy determines whether objects created within it
are transient or persistent. The Root POA has the <TT>TRANSIENT</TT>
policy.</P><P>An alternative to creating persistent objects is to register object
references in a <I>naming service</I> and bind them to fixed path
names. Clients can bind to the object implementations at run time by
asking the naming service to resolve the path names to the object
references. CORBA defines a standard naming service, which is a
component of the Common Object Services (COS)&#XA0;[<A HREF="#corbaservices">OMG98</A>],
that can be used for this purpose. The next section describes an
example of how to use the COS Naming Service.</P><!--TOC section Example 3 &#X2014; Using the Naming Service-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc36">2.10</A>&#XA0;&#XA0;Example 3 &#X2014; Using the Naming Service</H2><!--SEC END --><P>In this example, the object implementation uses the Naming
Service&#XA0;[<A HREF="#corbaservices">OMG98</A>] to pass on the object reference to the
client. This method is often more practical than using stringified
object references. The full listing of the object implementation
(<TT>eg3_impl.cc</TT>) and the client (<TT>eg3_clt.cc</TT>) can be found
at the end of this chapter.</P><P>The names used by the Naming service consist of a sequence of
<I>name components</I>. Each name component has an <I>id</I> and a
<I>kind</I> field, both of which are strings. All name components
except the last one are bound to a naming context. A naming context is
analogous to a directory in a filing system: it can contain names of
object references or other naming contexts. The last name component is
bound to an object reference.</P><P>Sequences of name components can be represented as a flat string,
using &#X2018;.&#X2019; to separate the id and kind fields, and &#X2018;/&#X2019; to separate name
components from each other<SUP><A NAME="text9" HREF="#note9">8</A></SUP>. In our example, the Echo object
reference is bound to the stringified name
&#X2018;<TT>test.my_context/Echo.Object</TT>&#X2019;.</P><P>The kind field is intended to describe the name in a
syntax-independent way. The naming service does not interpret, assign,
or manage these values. However, both the name and the kind attribute
must match for a name lookup to succeed. In this example, the kind
values for <TT>test</TT> and <TT>Echo</TT> are chosen to be
&#X2018;<TT>my_context</TT>&#X2019; and &#X2018;<TT>Object</TT>&#X2019; respectively. This is an
arbitrary choice as there is no standardised set of kind values.</P><!--TOC subsection Obtaining the Root Context Object Reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">2.10.1</A>&#XA0;&#XA0;Obtaining the Root Context Object Reference</H3><!--SEC END --><P>
<A NAME="resolveinit"></A></P><P>The initial contact with the Naming Service can be established via the
<I>root</I> context. The object reference to the root context is
provided by the ORB and can be obtained by calling
<TT>resolve_initial_references()</TT>. The following code fragment shows
how it is used:</P><DIV CLASS="lstlisting">CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv);
CORBA::Object_var obj = orb-&gt;resolve_initial_references("NameService");

CosNaming::NamingContext_var rootContext;
rootContext = CosNaming::NamingContext::_narrow(obj);</DIV><P>Remember from section&#XA0;<A HREF="#sec:setup">1.2</A>, omniORB constructs its internal
list of initial references at initialisation time using the
information provided in the configuration file <TT>omniORB.cfg</TT>, or
given on the command line. If this file is not present, the internal
list will be empty and <TT>resolve_initial_references()</TT> will raise a
<TT>CORBA::ORB::InvalidName</TT> exception.</P><!--TOC subsection The Naming Service Interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">2.10.2</A>&#XA0;&#XA0;The Naming Service Interface</H3><!--SEC END --><P>It is beyond the scope of this chapter to describe in detail the
Naming Service interface. You should consult the CORBA services
specification&#XA0;[<A HREF="#corbaservices">OMG98</A>] (chapter 3). The code listed in
<TT>eg3_impl.cc</TT> and <TT>eg3_clt.cc</TT> are good examples of how the
service can be used.</P><!--TOC section Example 4 &#X2014; Using tie implementation templates-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">2.11</A>&#XA0;&#XA0;Example 4 &#X2014; Using tie implementation templates</H2><!--SEC END --><P>
<A NAME="sec:tie"></A></P><P>omniORB supports <I>tie</I> implementation templates as an alternative
way of providing servant classes. If you use the <TT>-Wbtp</TT> option
to omniidl, it generates an extra template class for each interface.
This template class can be used to tie a C++ class to the skeleton
class of the interface.</P><P>The source code in <TT>eg3_tieimpl.cc</TT> at the end of this chapter
illustrates how the template class can be used. The code is almost
identical to <TT>eg3_impl.cc</TT> with only a few changes.</P><P>Firstly, the servant class <TT>Echo_i</TT> does not inherit from any
skeleton classes. This is the main benefit of using the template class
because there are applications in which it is difficult to require
every servant class to derive from CORBA classes.</P><P>Secondly, the instantiation of a CORBA object now involves creating an
instance of the implementation class <EM>and</EM> an instance of the
template. Here is the relevant code fragment:</P><DIV CLASS="lstlisting"><B>class</B> Echo_i { ... };

Echo_i *myimpl = <B>new</B> Echo_i();
POA_Echo_tie&lt;Echo_i&gt; myecho(myimpl);

PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(&amp;myecho);</DIV><P>For interface <TT>Echo</TT>, the name of its tie implementation template
is <TT>POA_Echo_tie</TT>. The template parameter is the servant
class that contains an implementation of each of the operations
defined in the interface. As used above, the tie template takes
ownership of the <TT>Echo_i</TT> instance, and deletes it when the tie
object goes out of scope. The tie constructor has an optional boolean
argument (defaulted to <TT>true</TT>) which indicates whether or not it
should delete the servant object. For full details of using tie
templates, see the CORBA C++ mapping specification.</P><!--TOC section Source Listings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc40">2.12</A>&#XA0;&#XA0;Source Listings</H2><!--SEC END --><!--TOC subsection eg1.cc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">2.12.1</A>&#XA0;&#XA0;eg1.cc</H3><!--SEC END --><DIV CLASS="lstlisting"><I>// eg1.cc - This is the source code of example 1 used in Chapter 2</I>
<I>//          "The Basics" of the omniORB user guide.</I>
<I>//</I>
<I>//          In this example, both the object implementation and the</I>
<I>//          client are in the same process.</I>
<I>//</I>
<I>// Usage: eg1</I>
<I>//</I>

<B>#include</B> &lt;echo.hh&gt;

<B>#ifdef</B> HAVE_STD
<B>#  include</B> &lt;iostream&gt;
   <B>using</B> <B>namespace</B> std;
<B>#else</B>
<B>#  include</B> &lt;iostream.h&gt;
<B>#endif</B>

<I>// This is the object implementation.</I>

<B>class</B> Echo_i : <B>public</B> POA_Echo
{
<B>public</B>:
  <B>inline</B> Echo_i() {}
  <B>virtual</B> ~Echo_i() {}
  <B>virtual</B> <B>char</B>* echoString(<B>const</B> <B>char</B>* mesg);
};


<B>char</B>* Echo_i::echoString(<B>const</B> <B>char</B>* mesg)
{
  <I>// Memory management rules say we must return a newly allocated</I>
  <I>// string.</I>
  <B>return</B> CORBA::string_dup(mesg);
}


<I>//////////////////////////////////////////////////////////////////////</I>

<I>// This function acts as a client to the object.</I>

<B>static</B> <B>void</B> hello(Echo_ptr e)
{
  <B>if</B>( CORBA::is_nil(e) ) {
    cerr &lt;&lt; "hello: The object reference is nil!" &lt;&lt; endl;
    <B>return</B>;
  }

  CORBA::String_var src = (<B>const</B> <B>char</B>*) "Hello!";
  <I>// String literals are (char*) rather than (const char*) on some</I>
  <I>// old compilers.  Thus it is essential to cast to (const char*)</I>
  <I>// here to ensure that the string is copied, so that the</I>
  <I>// CORBA::String_var does not attempt to 'delete' the string</I>
  <I>// literal.</I>

  CORBA::String_var dest = e-&gt;echoString(src);

  cout &lt;&lt; "I said, \"" &lt;&lt; (<B>char</B>*)src &lt;&lt; "\"." &lt;&lt; endl
       &lt;&lt; "The Echo object replied, \"" &lt;&lt; (<B>char</B>*)dest &lt;&lt;"\"." &lt;&lt; endl;
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>int</B> main(<B>int</B> argc, <B>char</B>** argv)
{
  <B>try</B> {
    <I>// Initialise the ORB.</I>
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    <I>// Obtain a reference to the root POA.</I>
    CORBA::Object_var       obj = orb-&gt;resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    <I>// We allocate the servant (implementation object) on the heap.</I>
    <I>// The servant is reference counted. We start out holding a</I>
    <I>// reference, and when the object is activated, the POA holds</I>
    <I>// another reference. The PortableServer::Servant_var&lt;&gt; template</I>
    <I>// automatically releases our reference when it goes out of scope.</I>
    PortableServer::Servant_var&lt;Echo_i&gt; myecho = <B>new</B> Echo_i();

    <I>// Activate the object. This tells the POA that this object is</I>
    <I>// ready to accept requests.</I>
    PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(myecho);

    <I>// Obtain a reference to the object.</I>
    Echo_var myechoref = myecho-&gt;_this();

    <I>// Obtain a POAManager, and tell the POA to start accepting</I>
    <I>// requests on its objects.</I>
    PortableServer::POAManager_var pman = poa-&gt;the_POAManager();
    pman-&gt;activate();

    <I>// Do the client-side call.</I>
    hello(myechoref);

    <I>// Clean up all the resources.</I>
    orb-&gt;destroy();
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::" &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::Exception&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::Exception: " &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>return</B> 0;
}</DIV><!--TOC subsection eg2_impl.cc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">2.12.2</A>&#XA0;&#XA0;eg2_impl.cc</H3><!--SEC END --><DIV CLASS="lstlisting"><I>// eg2_impl.cc - This is the source code of example 2 used in Chapter 2</I>
<I>//               "The Basics" of the omniORB user guide.</I>
<I>//</I>
<I>//               This is the object implementation.</I>
<I>//</I>
<I>// Usage: eg2_impl</I>
<I>//</I>
<I>//        On startup, the object reference is printed to cout as a</I>
<I>//        stringified IOR. This string should be used as the argument to</I>
<I>//        eg2_clt.</I>
<I>//</I>

<B>#include</B> &lt;echo.hh&gt;

<B>#ifdef</B> HAVE_STD
<B>#  include</B> &lt;iostream&gt;
   <B>using</B> <B>namespace</B> std;
<B>#else</B>
<B>#  include</B> &lt;iostream.h&gt;
<B>#endif</B>


<B>class</B> Echo_i : <B>public</B> POA_Echo
{
<B>public</B>:
  <B>inline</B> Echo_i() {}
  <B>virtual</B> ~Echo_i() {}
  <B>virtual</B> <B>char</B>* echoString(<B>const</B> <B>char</B>* mesg);
};


<B>char</B>* Echo_i::echoString(<B>const</B> <B>char</B>* mesg)
{
  cout &lt;&lt; "Upcall: " &lt;&lt; mesg &lt;&lt; endl;
  <B>return</B> CORBA::string_dup(mesg);
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>int</B> main(<B>int</B> argc, <B>char</B>** argv)
{
  <B>try</B> {
    CORBA::ORB_var          orb = CORBA::ORB_init(argc, argv);
    CORBA::Object_var       obj = orb-&gt;resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    PortableServer::Servant_var&lt;Echo_i&gt; myecho = <B>new</B> Echo_i();

    PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(myecho);

    <I>// Obtain a reference to the object, and print it out as a</I>
    <I>// stringified IOR.</I>
    obj = myecho-&gt;_this();
    CORBA::String_var sior(orb-&gt;object_to_string(obj));
    cout &lt;&lt; sior &lt;&lt; endl;

    PortableServer::POAManager_var pman = poa-&gt;the_POAManager();
    pman-&gt;activate();

    <I>// Block until the ORB is shut down.</I>
    orb-&gt;run();
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::" &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::Exception&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::Exception: " &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>return</B> 0;
}</DIV><!--TOC subsection eg2_clt.cc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">2.12.3</A>&#XA0;&#XA0;eg2_clt.cc</H3><!--SEC END --><DIV CLASS="lstlisting"><I>// eg2_clt.cc - This is the source code of example 2 used in Chapter 2</I>
<I>//              "The Basics" of the omniORB user guide.</I>
<I>//</I>
<I>//              This is the client. The object reference is given as a</I>
<I>//              stringified IOR on the command line.</I>
<I>//</I>
<I>// Usage: eg2_clt &lt;object reference&gt;</I>
<I>//</I>

<B>#include</B> &lt;echo.hh&gt;

<B>#ifdef</B> HAVE_STD
<B>#  include</B> &lt;iostream&gt;
   <B>using</B> <B>namespace</B> std;
<B>#else</B>
<B>#  include</B> &lt;iostream.h&gt;
<B>#endif</B>


<B>static</B> <B>void</B> hello(Echo_ptr e)
{
  CORBA::String_var src = (<B>const</B> <B>char</B>*) "Hello!";

  CORBA::String_var dest = e-&gt;echoString(src);

  cout &lt;&lt; "I said, \"" &lt;&lt; (<B>char</B>*)src &lt;&lt; "\"." &lt;&lt; endl
       &lt;&lt; "The Echo object replied, \"" &lt;&lt; (<B>char</B>*)dest &lt;&lt;"\"." &lt;&lt; endl;
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>int</B> main(<B>int</B> argc, <B>char</B>** argv)
{
  <B>try</B> {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    <B>if</B> (argc != 2) {
      cerr &lt;&lt; "usage:  eg2_clt &lt;object reference&gt;" &lt;&lt; endl;
      <B>return</B> 1;
    }

    CORBA::Object_var obj = orb-&gt;string_to_object(argv[1]);

    Echo_var echoref = Echo::_narrow(obj);

    <B>if</B> (CORBA::is_nil(echoref)) {
      cerr &lt;&lt; "Can't narrow reference to type Echo (or it was nil)." &lt;&lt; endl;
      <B>return</B> 1;
    }

    <B>for</B> (CORBA::ULong count=0; count&lt;10; count++)
      hello(echoref);

    orb-&gt;destroy();
  }
  <B>catch</B> (CORBA::TRANSIENT&amp;) {
    cerr &lt;&lt; "Caught system exception TRANSIENT -- unable to contact the "
         &lt;&lt; "server." &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught a CORBA::" &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::Exception&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::Exception: " &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>return</B> 0;
}</DIV><!--TOC subsection eg3_impl.cc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">2.12.4</A>&#XA0;&#XA0;eg3_impl.cc</H3><!--SEC END --><DIV CLASS="lstlisting"><I>// eg3_impl.cc - This is the source code of example 3 used in Chapter 2</I>
<I>//               "The Basics" of the omniORB user guide.</I>
<I>//</I>
<I>//               This is the object implementation.</I>
<I>//</I>
<I>// Usage: eg3_impl</I>
<I>//</I>
<I>//        On startup, the object reference is registered with the</I>
<I>//        COS naming service. The client uses the naming service to</I>
<I>//        locate this object.</I>
<I>//</I>
<I>//        The name which the object is bound to is as follows:</I>
<I>//              root  [context]</I>
<I>//               |</I>
<I>//              test  [context] kind [my_context]</I>
<I>//               |</I>
<I>//              Echo  [object]  kind [Object]</I>
<I>//</I>

<B>#include</B> &lt;echo.hh&gt;

<B>#ifdef</B> HAVE_STD
<B>#  include</B> &lt;iostream&gt;
   <B>using</B> <B>namespace</B> std;
<B>#else</B>
<B>#  include</B> &lt;iostream.h&gt;
<B>#endif</B>

<B>static</B> CORBA::Boolean bindObjectToName(CORBA::ORB_ptr, CORBA::Object_ptr);


<B>class</B> Echo_i : <B>public</B> POA_Echo
{
<B>public</B>:
  <B>inline</B> Echo_i() {}
  <B>virtual</B> ~Echo_i() {}
  <B>virtual</B> <B>char</B>* echoString(<B>const</B> <B>char</B>* mesg);
};


<B>char</B>* Echo_i::echoString(<B>const</B> <B>char</B>* mesg)
{
  <B>return</B> CORBA::string_dup(mesg);
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>int</B>
main(<B>int</B> argc, <B>char</B> **argv)
{
  <B>try</B> {
    CORBA::ORB_var          orb = CORBA::ORB_init(argc, argv);
    CORBA::Object_var       obj = orb-&gt;resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    PortableServer::Servant_var&lt;Echo_i&gt; myecho = <B>new</B> Echo_i();

    PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(myecho);

    <I>// Obtain a reference to the object, and register it in</I>
    <I>// the naming service.</I>
    obj = myecho-&gt;_this();

    CORBA::String_var sior(orb-&gt;object_to_string(obj));
    cout &lt;&lt; sior &lt;&lt; endl;

    <B>if</B> (!bindObjectToName(orb, obj))
      <B>return</B> 1;

    PortableServer::POAManager_var pman = poa-&gt;the_POAManager();
    pman-&gt;activate();

    orb-&gt;run();
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::" &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::Exception&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::Exception: " &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>return</B> 0;
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>static</B> CORBA::Boolean
bindObjectToName(CORBA::ORB_ptr orb, CORBA::Object_ptr objref)
{
  CosNaming::NamingContext_var rootContext;

  <B>try</B> {
    <I>// Obtain a reference to the root context of the Name service:</I>
    CORBA::Object_var obj = orb-&gt;resolve_initial_references("NameService");

    <I>// Narrow the reference returned.</I>
    rootContext = CosNaming::NamingContext::_narrow(obj);
    <B>if</B> (CORBA::is_nil(rootContext)) {
      cerr &lt;&lt; "Failed to narrow the root naming context." &lt;&lt; endl;
      <B>return</B> 0;
    }
  }
  <B>catch</B> (CORBA::NO_RESOURCES&amp;) {
    cerr &lt;&lt; "Caught NO_RESOURCES exception. You must configure omniORB "
         &lt;&lt; "with the location" &lt;&lt; endl
         &lt;&lt; "of the naming service." &lt;&lt; endl;
    <B>return</B> 0;
  }
  <B>catch</B> (CORBA::ORB::InvalidName&amp;) {
    <I>// This should not happen!</I>
    cerr &lt;&lt; "Service required is invalid [does not exist]." &lt;&lt; endl;
    <B>return</B> 0;
  }

  <B>try</B> {
    <I>// Bind a context called "test" to the root context:</I>

    CosNaming::Name contextName;
    contextName.length(1);
    contextName[0].id   = (<B>const</B> <B>char</B>*) "test";       <I>// string copied</I>
    contextName[0].kind = (<B>const</B> <B>char</B>*) "my_context"; <I>// string copied</I>
    <I>// Note on kind: The kind field is used to indicate the type</I>
    <I>// of the object. This is to avoid conventions such as that used</I>
    <I>// by files (name.type -- e.g. test.ps = postscript etc.)</I>

    CosNaming::NamingContext_var testContext;
    <B>try</B> {
      <I>// Bind the context to root.</I>
      testContext = rootContext-&gt;bind_new_context(contextName);
    }
    <B>catch</B>(CosNaming::NamingContext::AlreadyBound&amp; ex) {
      <I>// If the context already exists, this exception will be raised.</I>
      <I>// In this case, just resolve the name and assign testContext</I>
      <I>// to the object returned:</I>
      CORBA::Object_var obj = rootContext-&gt;resolve(contextName);
      testContext = CosNaming::NamingContext::_narrow(obj);
      <B>if</B> (CORBA::is_nil(testContext)) {
        cerr &lt;&lt; "Failed to narrow naming context." &lt;&lt; endl;
        <B>return</B> 0;
      }
    }

    <I>// Bind objref with name Echo to the testContext:</I>
    CosNaming::Name objectName;
    objectName.length(1);
    objectName[0].id   = (<B>const</B> <B>char</B>*) "Echo";   <I>// string copied</I>
    objectName[0].kind = (<B>const</B> <B>char</B>*) "Object"; <I>// string copied</I>

    <B>try</B> {
      testContext-&gt;bind(objectName, objref);
    }
    <B>catch</B>(CosNaming::NamingContext::AlreadyBound&amp; ex) {
      testContext-&gt;rebind(objectName, objref);
    }
    <I>// Note: Using rebind() will overwrite any Object previously bound</I>
    <I>//       to /test/Echo with obj.</I>
    <I>//       Alternatively, bind() can be used, which will raise a</I>
    <I>//       CosNaming::NamingContext::AlreadyBound exception if the name</I>
    <I>//       supplied is already bound to an object.</I>
  }
  <B>catch</B> (CORBA::TRANSIENT&amp; ex) {
    cerr &lt;&lt; "Caught system exception TRANSIENT -- unable to contact the "
         &lt;&lt; "naming service." &lt;&lt; endl
         &lt;&lt; "Make sure the naming server is running and that omniORB is "
         &lt;&lt; "configured correctly." &lt;&lt; endl;

    <B>return</B> 0;
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught a CORBA::" &lt;&lt; ex._name()
         &lt;&lt; " while using the naming service." &lt;&lt; endl;
    <B>return</B> 0;
  }
  <B>return</B> 1;
}</DIV><!--TOC subsection eg3_clt.cc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">2.12.5</A>&#XA0;&#XA0;eg3_clt.cc</H3><!--SEC END --><DIV CLASS="lstlisting"><I>// eg3_clt.cc - This is the source code of example 3 used in Chapter 2</I>
<I>//              "The Basics" of the omniORB user guide.</I>
<I>//</I>
<I>//              This is the client. It uses the COSS naming service</I>
<I>//              to obtain the object reference.</I>
<I>//</I>
<I>// Usage: eg3_clt</I>
<I>//</I>
<I>//</I>
<I>//        On startup, the client lookup the object reference from the</I>
<I>//        COS naming service.</I>
<I>//</I>
<I>//        The name which the object is bound to is as follows:</I>
<I>//              root  [context]</I>
<I>//               |</I>
<I>//              text  [context] kind [my_context]</I>
<I>//               |</I>
<I>//              Echo  [object]  kind [Object]</I>
<I>//</I>

<B>#include</B> &lt;echo.hh&gt;

<B>#ifdef</B> HAVE_STD
<B>#  include</B> &lt;iostream&gt;
   <B>using</B> <B>namespace</B> std;
<B>#else</B>
<B>#  include</B> &lt;iostream.h&gt;
<B>#endif</B>

<B>static</B> CORBA::Object_ptr getObjectReference(CORBA::ORB_ptr orb);

<B>static</B> <B>void</B> hello(Echo_ptr e)
{
  <B>if</B> (CORBA::is_nil(e)) {
    cerr &lt;&lt; "hello: The object reference is nil!\n" &lt;&lt; endl;
    <B>return</B>;
  }

  CORBA::String_var src = (<B>const</B> <B>char</B>*) "Hello!";

  CORBA::String_var dest = e-&gt;echoString(src);

  cerr &lt;&lt; "I said, \"" &lt;&lt; (<B>char</B>*)src &lt;&lt; "\"." &lt;&lt; endl
       &lt;&lt; "The Echo object replied, \"" &lt;&lt; (<B>char</B>*)dest &lt;&lt;"\"." &lt;&lt; endl;
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>int</B>
main (<B>int</B> argc, <B>char</B> **argv)
{
  <B>try</B> {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    CORBA::Object_var obj = getObjectReference(orb);

    Echo_var echoref = Echo::_narrow(obj);

    <B>for</B> (CORBA::ULong count=0; count &lt; 10; count++)
      hello(echoref);

    orb-&gt;destroy();
  }
  <B>catch</B> (CORBA::TRANSIENT&amp;) {
    cerr &lt;&lt; "Caught system exception TRANSIENT -- unable to contact the "
         &lt;&lt; "server." &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught a CORBA::" &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::Exception&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::Exception: " &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>return</B> 0;
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>static</B> CORBA::Object_ptr
getObjectReference(CORBA::ORB_ptr orb)
{
  CosNaming::NamingContext_var rootContext;

  <B>try</B> {
    <I>// Obtain a reference to the root context of the Name service:</I>
    CORBA::Object_var obj;
    obj = orb-&gt;resolve_initial_references("NameService");

    <I>// Narrow the reference returned.</I>
    rootContext = CosNaming::NamingContext::_narrow(obj);

    <B>if</B> (CORBA::is_nil(rootContext)) {
      cerr &lt;&lt; "Failed to narrow the root naming context." &lt;&lt; endl;
      <B>return</B> CORBA::Object::_nil();
    }
  }
  <B>catch</B> (CORBA::NO_RESOURCES&amp;) {
    cerr &lt;&lt; "Caught NO_RESOURCES exception. You must configure omniORB "
         &lt;&lt; "with the location" &lt;&lt; endl
         &lt;&lt; "of the naming service." &lt;&lt; endl;
    <B>return</B> CORBA::Object::_nil();
  }
  <B>catch</B> (CORBA::ORB::InvalidName&amp; ex) {
    <I>// This should not happen!</I>
    cerr &lt;&lt; "Service required is invalid [does not exist]." &lt;&lt; endl;
    <B>return</B> CORBA::Object::_nil();
  }

  <I>// Create a name object, containing the name test/context:</I>
  CosNaming::Name name;
  name.length(2);

  name[0].id   = (<B>const</B> <B>char</B>*) "test";       <I>// string copied</I>
  name[0].kind = (<B>const</B> <B>char</B>*) "my_context"; <I>// string copied</I>
  name[1].id   = (<B>const</B> <B>char</B>*) "Echo";
  name[1].kind = (<B>const</B> <B>char</B>*) "Object";
  <I>// Note on kind: The kind field is used to indicate the type</I>
  <I>// of the object. This is to avoid conventions such as that used</I>
  <I>// by files (name.type -- e.g. test.ps = postscript etc.)</I>

  <B>try</B> {
    <I>// Resolve the name to an object reference.</I>
    <B>return</B> rootContext-&gt;resolve(name);
  }
  <B>catch</B> (CosNaming::NamingContext::NotFound&amp; ex) {
    <I>// This exception is thrown if any of the components of the</I>
    <I>// path [contexts or the object] aren't found:</I>
    cerr &lt;&lt; "Context not found." &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::TRANSIENT&amp; ex) {
    cerr &lt;&lt; "Caught system exception TRANSIENT -- unable to contact the "
         &lt;&lt; "naming service." &lt;&lt; endl
         &lt;&lt; "Make sure the naming server is running and that omniORB is "
         &lt;&lt; "configured correctly." &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught a CORBA::" &lt;&lt; ex._name()
         &lt;&lt; " while using the naming service." &lt;&lt; endl;
  }
  <B>return</B> CORBA::Object::_nil();
}</DIV><!--TOC subsection eg3_tieimpl.cc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">2.12.6</A>&#XA0;&#XA0;eg3_tieimpl.cc</H3><!--SEC END --><DIV CLASS="lstlisting"><I>// eg3_tieimpl.cc - This example is similar to eg3_impl.cc except that</I>
<I>//                  the tie implementation skeleton is used.</I>
<I>//</I>
<I>//               This is the object implementation.</I>
<I>//</I>
<I>// Usage: eg3_tieimpl</I>
<I>//</I>
<I>//        On startup, the object reference is registered with the </I>
<I>//        COS naming service. The client uses the naming service to</I>
<I>//        locate this object.</I>
<I>//</I>
<I>//        The name which the object is bound to is as follows:</I>
<I>//              root  [context]</I>
<I>//               |</I>
<I>//              test  [context] kind [my_context]</I>
<I>//               |</I>
<I>//              Echo  [object]  kind [Object]</I>
<I>//</I>

<B>#include</B> &lt;echo.hh&gt;

<B>#ifdef</B> HAVE_STD
<B>#  include</B> &lt;iostream&gt;
   <B>using</B> <B>namespace</B> std;
<B>#else</B>
<B>#  include</B> &lt;iostream.h&gt;
<B>#endif</B>

<B>static</B> CORBA::Boolean bindObjectToName(CORBA::ORB_ptr, CORBA::Object_ptr);


<I>// This is the object implementation.  Notice that it does not inherit</I>
<I>// from any skeleton class, and notice that the echoString() member</I>
<I>// function does not have to be virtual.</I>

<B>class</B> Echo_i {
<B>public</B>:
  <B>inline</B> Echo_i() {}
  <B>inline</B> ~Echo_i() {}
  <B>char</B>* echoString(<B>const</B> <B>char</B>* mesg);
};


<B>char</B>* Echo_i::echoString(<B>const</B> <B>char</B>* mesg)
{
  <B>return</B> CORBA::string_dup(mesg);
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>int</B> main(<B>int</B> argc, <B>char</B>** argv)
{
  <B>try</B> {
    CORBA::ORB_var          orb = CORBA::ORB_init(argc, argv);
    CORBA::Object_var       obj = orb-&gt;resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    <I>// Note that the &lt;myecho&gt; tie object is constructed on the stack</I>
    <I>// here. It will delete its implementation (myimpl) when it it</I>
    <I>// itself destroyed (when it goes out of scope).  It is essential</I>
    <I>// however to ensure that such servants are not deleted whilst</I>
    <I>// still activated.</I>
    <I>//</I>
    <I>// Tie objects can of course be allocated on the heap using new,</I>
    <I>// in which case they are deleted when their reference count</I>
    <I>// becomes zero, as with any other servant object.</I>
    Echo_i* myimpl = <B>new</B> Echo_i();
    POA_Echo_tie&lt;Echo_i&gt; myecho(myimpl);

    PortableServer::ObjectId_var myechoid = poa-&gt;activate_object(&amp;myecho);

    <I>// Obtain a reference to the object, and register it in</I>
    <I>// the naming service.</I>
    obj = myecho._this();
    <B>if</B> (!bindObjectToName(orb, obj))
      <B>return</B> 1;

    PortableServer::POAManager_var pman = poa-&gt;the_POAManager();
    pman-&gt;activate();

    orb-&gt;run();
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::" &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>catch</B> (CORBA::Exception&amp; ex) {
    cerr &lt;&lt; "Caught CORBA::Exception: " &lt;&lt; ex._name() &lt;&lt; endl;
  }
  <B>return</B> 0;
}

<I>//////////////////////////////////////////////////////////////////////</I>

<B>static</B> CORBA::Boolean
bindObjectToName(CORBA::ORB_ptr orb, CORBA::Object_ptr objref)
{
  CosNaming::NamingContext_var rootContext;

  <B>try</B> {
    <I>// Obtain a reference to the root context of the Name service:</I>
    CORBA::Object_var obj = orb-&gt;resolve_initial_references("NameService");

    <I>// Narrow the reference returned.</I>
    rootContext = CosNaming::NamingContext::_narrow(obj);
    <B>if</B> (CORBA::is_nil(rootContext)) {
      cerr &lt;&lt; "Failed to narrow the root naming context." &lt;&lt; endl;
      <B>return</B> 0;
    }
  }
  <B>catch</B> (CORBA::NO_RESOURCES&amp;) {
    cerr &lt;&lt; "Caught NO_RESOURCES exception. You must configure omniORB "
         &lt;&lt; "with the location" &lt;&lt; endl
         &lt;&lt; "of the naming service." &lt;&lt; endl;
    <B>return</B> 0;
  }
  <B>catch</B> (CORBA::ORB::InvalidName&amp;) {
    <I>// This should not happen!</I>
    cerr &lt;&lt; "Service required is invalid [does not exist]." &lt;&lt; endl;
    <B>return</B> 0;
  }

  <B>try</B> {
    <I>// Bind a context called "test" to the root context:</I>

    CosNaming::Name contextName;
    contextName.length(1);
    contextName[0].id   = (<B>const</B> <B>char</B>*) "test";       <I>// string copied</I>
    contextName[0].kind = (<B>const</B> <B>char</B>*) "my_context"; <I>// string copied</I>
    <I>// Note on kind: The kind field is used to indicate the type</I>
    <I>// of the object. This is to avoid conventions such as that used</I>
    <I>// by files (name.type -- e.g. test.ps = postscript etc.)</I>

    CosNaming::NamingContext_var testContext;
    <B>try</B> {
      <I>// Bind the context to root.</I>
      testContext = rootContext-&gt;bind_new_context(contextName);
    }
    <B>catch</B>(CosNaming::NamingContext::AlreadyBound&amp; ex) {
      <I>// If the context already exists, this exception will be raised.</I>
      <I>// In this case, just resolve the name and assign testContext</I>
      <I>// to the object returned:</I>
      CORBA::Object_var obj = rootContext-&gt;resolve(contextName);
      testContext = CosNaming::NamingContext::_narrow(obj);
      <B>if</B> (CORBA::is_nil(testContext)) {
        cerr &lt;&lt; "Failed to narrow naming context." &lt;&lt; endl;
        <B>return</B> 0;
      }
    }

    <I>// Bind objref with name Echo to the testContext:</I>
    CosNaming::Name objectName;
    objectName.length(1);
    objectName[0].id   = (<B>const</B> <B>char</B>*) "Echo";   <I>// string copied</I>
    objectName[0].kind = (<B>const</B> <B>char</B>*) "Object"; <I>// string copied</I>

    <B>try</B> {
      testContext-&gt;bind(objectName, objref);
    }
    <B>catch</B>(CosNaming::NamingContext::AlreadyBound&amp; ex) {
      testContext-&gt;rebind(objectName, objref);
    }
    <I>// Note: Using rebind() will overwrite any Object previously bound</I>
    <I>//       to /test/Echo with obj.</I>
    <I>//       Alternatively, bind() can be used, which will raise a</I>
    <I>//       CosNaming::NamingContext::AlreadyBound exception if the name</I>
    <I>//       supplied is already bound to an object.</I>
  }
  <B>catch</B> (CORBA::TRANSIENT&amp; ex) {
    cerr &lt;&lt; "Caught system exception TRANSIENT -- unable to contact the "
         &lt;&lt; "naming service." &lt;&lt; endl
         &lt;&lt; "Make sure the naming server is running and that omniORB is "
         &lt;&lt; "configured correctly." &lt;&lt; endl;

    <B>return</B> 0;
  }
  <B>catch</B> (CORBA::SystemException&amp; ex) {
    cerr &lt;&lt; "Caught a CORBA::" &lt;&lt; ex._name()
         &lt;&lt; " while using the naming service." &lt;&lt; endl;
    <B>return</B> 0;
  }
  <B>return</B> 1;
}</DIV><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note2" HREF="#text2">1</A></DT><DD CLASS="dd-thefootnotes">Rather than
deriving from the skeleton class, an alternative is to use a
<I>tie</I> template, described in section&#XA0;<A HREF="#sec:tie">2.11</A>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">2</A></DT><DD CLASS="dd-thefootnotes">In the previous 1.0 version of the C++
mapping, servant reference counting was optional, chosen by inheriting
from a mixin class named <TT>RefCountServantBase</TT>. That has been
deprecated in the 1.1 version of the C++ mapping, but the class is
still available as an empty struct, so existing code that inherits
from <TT>RefCountServantBase</TT> will continue to work.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">3</A></DT><DD CLASS="dd-thefootnotes">A conversion operator of
<TT>CORBA::String_var</TT> converts a <TT>CORBA::String_var</TT>
to a <TT>char*</TT>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">4</A></DT><DD CLASS="dd-thefootnotes">Please refer to the C++
mapping specification for details of the String_var mapping.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">5</A></DT><DD CLASS="dd-thefootnotes">For backwards compatibility, the ORB identifiers
&#X2018;omniORB2&#X2019; and &#X2018;omniORB3&#X2019; are also accepted.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">6</A></DT><DD CLASS="dd-thefootnotes">If a system exception is not caught, the C++
runtime will call the <TT>terminate()</TT> function. This function is
defaulted to abort the whole process and on some systems will cause a
core file to be produced.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">7</A></DT><DD CLASS="dd-thefootnotes">The POA itself can be activated on demand
with an adapter activator.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note9" HREF="#text9">8</A></DT><DD CLASS="dd-thefootnotes">There are escaping rules to cope
with id and kind fields which contain &#X2018;.&#X2019; and &#X2018;/&#X2019; characters. See
chapter&#XA0;<A HREF="#chap:ins">7</A> of this manual, and chapter 3 of the CORBA
services specification, as updated for the Interoperable Naming
Service&#XA0;[<A HREF="#inschapters">OMG00</A>].
</DD></DL>
<!--END NOTES-->
<!--TOC chapter C++ language mapping-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc47">Chapter&#XA0;3</A>&#XA0;&#XA0;C++ language mapping</H1><!--SEC END --><P>Now that you are familiar with the basics, it is important to
familiarise yourself with the standard IDL to C++ language mapping.
The mapping is described in detail in&#XA0;[<A HREF="#cxxmapping">OMG03</A>]. If you have
not done so, you should obtain a copy of the document and use that as
the programming guide to omniORB.</P><P>The specification is not an easy read. The alternative is to use one
of the books on CORBA programming. For instance, Henning and Vinoski&#X2019;s
&#X2018;Advanced CORBA Programming with C++&#X2019;&#XA0;[<A HREF="#henning1999">HV99</A>] includes many
example code fragments to illustrate how to use the C++ mapping.</P><!--TOC section omniORB 2 BOA compatibility-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc48">3.1</A>&#XA0;&#XA0;omniORB 2 BOA compatibility</H2><!--SEC END --><P>
<A NAME="sec:BOAcompat"></A></P><P>Before the Portable Object Adapter (POA) specification, many of the
details of how servant objects should be implemented and registered
with the system were unspecified, so server-side code was not portable
between ORBs. The POA specification rectifies that. For compatibility,
omniORB 4 still supports the old omniORB 2.x BOA mapping, but you
should always use the POA mapping for new code. BOA code and POA code
can coexist within a single program. </P><P>If you use the <TT>-WbBOA</TT> option to omniidl, it will generate
skeleton code with (nearly) the same interface as the old omniORB 2
BOA mapping, as well as code to be used with the POA. Note that since
the major problem with the BOA specification was that server code was
not portable between ORBs, it is unlikely that omniORB&#X2019;s BOA
compatibility will help you much if you are moving from a different
BOA-based ORB.</P><P>The BOA compatibility permits the majority of BOA code to compile
without difficulty. However, there are a number of constructs which
relied on omniORB 2 implementation details which no longer work.</P><UL CLASS="itemize"><LI CLASS="li-itemize">omniORB 2 did not use distinct types for object references and
servants, and often accepted a pointer to a servant when the CORBA
specification says it should only accept an object reference. Such
code will not compile under omniORB 4.</LI><LI CLASS="li-itemize">The reverse is true for <TT>BOA::obj_is_ready()</TT>. It now only
works when passed a pointer to a servant object, not an object
reference. The more commonly used mechanism of calling
<TT>_obj_is_ready(boa)</TT> on the servant object still works as
expected.</LI><LI CLASS="li-itemize">It used to be the case that the skeleton class for interface
<TT>I</TT> (<TT>_sk_I</TT>) was derived from class <TT>I</TT>. This meant
that the names of any types declared in the interface were available
in the scope of the skeleton class. This is no longer true. If you
have an interface:<DIV CLASS="lstlisting"><B>interface</B> I {
  <B>struct</B> S {
    <B>long</B> a,b;
  };
  S op();
};</DIV><P>then where before the implementation code might have been:</P><DIV CLASS="lstlisting"><B>class</B> I_impl : <B>public</B> <B>virtual</B> _sk_I {
  S op();  <I>// _sk_I is derived from I</I>
};
I::S I_impl::op() {
  S ret;
  <I>// ...</I>
}</DIV><P>it is now necessary to fully qualify all uses of <TT>S</TT>:</P><DIV CLASS="lstlisting"><B>class</B> I_impl : <B>public</B> <B>virtual</B> _sk_I {
  I::S op(); <I>// _sk_I is not derived from I</I>
};
I::S I_impl::op() {
  I::S ret;
  <I>// ...</I>
}</DIV></LI><LI CLASS="li-itemize">The proprietary omniORB 2 LifeCycle extensions are no longer
supported. All of the facilities it offered can be implemented with
the POA interfaces, and the <TT>omniORB::LOCATION_FORWARD</TT>
exception (see section&#XA0;<A HREF="#sec:locationForward">4.8</A>). Code which used the
old interfaces will have to be rewritten.</LI></UL><!--TOC section omniORB 3.0 compatibility-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">3.2</A>&#XA0;&#XA0;omniORB 3.0 compatibility</H2><!--SEC END --><P>omniORB 4 is almost completely source-code compatible with omniORB
3.0. There are two main cases where code may have to change. The first
is code that uses the omniORB API, some aspects of which have
changed. The omniORB configuration file also has a new format. See the
next chapter for details of the new API and configuration file.</P><P>The second case of code that may have to change is code using the
Dynamic Any interfaces. The standard changed quite significantly
between CORBA 2.2 and CORBA 2.3; omniORB 3.0 supported the old CORBA
2.2 interfaces; omniORB 4 uses the new mapping. The changes are
largely syntax changes, rather than semantic differences.</P><!--TOC section omniORB 4.0 compatibility-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">3.3</A>&#XA0;&#XA0;omniORB 4.0 compatibility</H2><!--SEC END --><P>omniORB 4.2 is source-code compatible with omniORB 4.0, with four
exceptions:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">As required by the 1.1 version of the CORBA C++ mapping
specification, the <TT>RefCountServantBase</TT> class has been
deprecated, and the reference counting functionality moved into
<TT>ServantBase</TT>. For backwards compatibility,
<TT>RefCountServantBase</TT> still exists, but is now defined as an
empty struct. Most code will continue to work unchanged, but code
that explicitly calls <TT>RefCountServantBase::_add_ref()</TT> or
<TT>_remove_ref()</TT> will no longer compile.</LI><LI CLASS="li-enumerate">omniORB 4.0 had an option for Any extraction semantics that was
compatible with omniORB 2.7, where ownership of extracted values was
not maintained by the Any. That option is no longer available.</LI><LI CLASS="li-enumerate">The members of the <TT>clientSendRequest</TT> interceptor have
been changed, replacing all the separate variables with a single
member of type <TT>GIOP_C</TT>. All the values previously available
can be accessed through the <TT>GIOP_C</TT> instance.</LI><LI CLASS="li-enumerate">The C++ mapping contains Any insertion operators for sequence
types that are passed by pointer, which cause the Any to take
ownership of the inserted sequence. In omniORB 4.0 and earlier, the
sequence was immediately marshalled into the Any&#X2019;s internal buffer,
and the sequence was deleted. In omniORB 4.1, the sequence pointer
is stored by the Any, and the sequence is deleted later when the Any
is destroyed.<P>For most uses, this change is not visible to application code.
However, if a sequence is constructed using an application-supplied
buffer with the release flag set to <TT>false</TT> (meaning that the
application continues to own the buffer), it is now important that
the buffer is not deleted or modified while the Any exists, since
the Any continues to refer to the buffer contents. This change
means that code that worked with omniORB 4.0 may now fail with 4.1,
with the Any seeing modified data or the process crashing due to
accessing deleted data. To avoid this situation, use the alternative
Any insertion operator using a const reference, which copies the
sequence.</P></LI></OL><!--TOC section omniORB 4.1 compatibility-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">3.4</A>&#XA0;&#XA0;omniORB 4.1 compatibility</H2><!--SEC END --><P>omniORB 4.2 is source-code compatible with omniORB 4.1 with one
exception:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">When omniORB 4.1 and earlier detected a timeout condition, they
would throw the <TT>CORBA::TRANSIENT</TT> system exception. omniORB
4.2 supports the <TT>CORBA::TIMEOUT</TT> system exception that was
introduced with the CORBA Messaging specification. Application code
that caught <TT>CORBA::TRANSIENT</TT> to handle timeout situations
should be updated to catch <TT>CORBA::TIMEOUT</TT>
instead. Alternatively, to avoid code changes, omniORB can be
configured to throw <TT>CORBA::TRANSIENT</TT> for timeouts, by setting
the <TT>throwTransientOnTimeout</TT> parameter to <TT>1</TT>. See
section&#XA0;<A HREF="#sec:clientconf">4.4</A>.</LI></OL><!--TOC chapter omniORB configuration and API-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc52">Chapter&#XA0;4</A>&#XA0;&#XA0;omniORB configuration and API</H1><!--SEC END --><P>
<A NAME="chap:config"></A></P><P>omniORB has a wide range of parameters that can be configured. They
can be set in the configuration file / Windows registry, as
environment variables, on the command line, or within a proprietary
extra argument to <TT>CORBA::ORB_init()</TT>. A few parameters can be
configured at run time. This chapter lists all the configuration
parameters, and how they are used.</P><!--TOC section Setting parameters-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">4.1</A>&#XA0;&#XA0;Setting parameters</H2><!--SEC END --><P>When <TT>CORBA::ORB_init()</TT> is called, the value for each configuration
parameter is searched for in the following order:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Command line arguments
</LI><LI CLASS="li-enumerate"><TT>ORB_init()</TT> options
</LI><LI CLASS="li-enumerate">Environment variables
</LI><LI CLASS="li-enumerate">Configuration file / Windows registry
</LI><LI CLASS="li-enumerate">Built-in defaults</LI></OL><!--TOC subsection Command line arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">4.1.1</A>&#XA0;&#XA0;Command line arguments</H3><!--SEC END --><P>Command line arguments take the form
&#X2018;<TT>-ORB</TT><I>parameter</I>&#X2019;, and usually expect another
argument. An example is &#X2018;<TT>-ORBtraceLevel 10</TT>&#X2019;.</P><!--TOC subsection ORB_init() parameter-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">4.1.2</A>&#XA0;&#XA0;ORB_init() parameter</H3><!--SEC END --><P><TT>ORB_init()</TT>&#X2019;s extra argument accepts an array of two-dimensional
string arrays, like this:</P><DIV CLASS="lstlisting"><B>const</B> <B>char</B>* options[][2] = { { "traceLevel", "1" }, { 0, 0 } };
orb = CORBA::ORB_init(argc,argv,"omniORB4",options);</DIV><!--TOC subsection Environment variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">4.1.3</A>&#XA0;&#XA0;Environment variables</H3><!--SEC END --><P>Environment variables consist of the parameter name prefixed with
&#X2018;<TT>ORB</TT>&#X2019;. Using bash, for example</P><DIV CLASS="lstlisting">export ORBtraceLevel=10</DIV><!--TOC subsection Configuration file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">4.1.4</A>&#XA0;&#XA0;Configuration file</H3><!--SEC END --><P>The best way to understand the format of the configuration file is to
look at the <TT>sample.cfg</TT> file in the omniORB distribution. Each
parameter is set on a single line like</P><PRE CLASS="verbatim">traceLevel = 10
</PRE><P>Some parameters can have more than one value, in which case the
parameter name may be specified more than once, or you can leave it
out:</P><PRE CLASS="verbatim">InitRef = NameService=corbaname::host1.example.com
        = InterfaceRepository=corbaloc::host2.example.com:1234/IfR
</PRE><DIV CLASS="minipage"><HR SIZE=2><DL CLASS="list"><DT CLASS="dt-list">

</DT><DD CLASS="dd-list">
Command line arguments and environment variables prefix parameter
names with &#X2018;-ORB&#X2019; and &#X2018;ORB&#X2019; respectively, but the configuration file
and the extra argument to <TT>ORB_init()</TT> do not use a prefix.
</DD></DL><HR SIZE=2></DIV><!--TOC subsection Windows registry-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">4.1.5</A>&#XA0;&#XA0;Windows registry</H3><!--SEC END --><P>On Windows, configuration parameters can be stored in the registry,
under the key <TT>HKEY_LOCAL_MACHINE\SOFTWARE\omniORB</TT>.</P><P>The file <TT>sample.reg</TT> shows the settings that can be made. It can
be edited and then imported into regedit.</P><!--TOC section Tracing options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc59">4.2</A>&#XA0;&#XA0;Tracing options</H2><!--SEC END --><P>The following options control debugging trace output.</P><P><TT>traceLevel</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>omniORB can output tracing and diagnostic messages to the standard
error stream. The following levels are defined:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
level 0</TD><TD VALIGN=top ALIGN=left>critical errors only</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 1</TD><TD VALIGN=top ALIGN=left>informational messages only</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 2</TD><TD VALIGN=top ALIGN=left>configuration information and warnings</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
level 5</TD><TD VALIGN=top ALIGN=left>notifications when server threads are
created and communication endpoints are shutdown</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
level 10</TD><TD VALIGN=top ALIGN=left>execution and exception traces</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 25</TD><TD VALIGN=top ALIGN=left>trace each send or receive of a GIOP message</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 30</TD><TD VALIGN=top ALIGN=left>dump up to 128 bytes of each GIOP message</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>level 40</TD><TD VALIGN=top ALIGN=left>dump complete contents of each GIOP message</TD></TR>
</TABLE><P>The trace level is cumulative, so at level 40, all trace
messages are output.</P><P><TT>traceExceptions</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If the <TT>traceExceptions</TT> parameter is set <TT>true</TT>, all system
exceptions are logged as they are thrown, along with details about
where the exception is thrown from. This parameter is enabled by
default if the traceLevel is set to 10 or more.</P><P><TT>traceInvocations</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If the <TT>traceInvocations</TT> parameter is set <TT>true</TT>, all local
and remote invocations are logged, in addition to any logging that may
have been selected with <TT>traceLevel</TT>.</P><P><TT>traceInvocationReturns</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If the <TT>traceInvocationReturns</TT> parameter is set <TT>true</TT>, a
log message is output as an operation invocation returns. In
conjunction with <TT>traceInvocations</TT> and <TT>traceTime</TT>
(described below), this provides a simple way of timing CORBA calls
within your application.</P><P><TT>traceThreadId</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>If <TT>traceThreadId</TT> is set <TT>true</TT>, all trace messages are
prefixed with the id of the thread outputting the message. This can be
handy for making sense of multi-threaded code, but it adds overhead to
the logging so it can be disabled.</P><P><TT>traceTime</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>If <TT>traceTime</TT> is set <TT>true</TT>, all trace messages are
prefixed with the time. This is useful, but on some platforms it adds
a very large overhead, so it can be turned off.</P><P><TT>traceFile</TT> &#XA0;&#XA0; <I>default</I> =
</P><P>omniORB&#X2019;s tracing is normally sent to stderr. If <TT>traceFile</TT> it
set, the specified file name is used for trace messages.</P><!--TOC subsection Tracing API-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">4.2.1</A>&#XA0;&#XA0;Tracing API</H3><!--SEC END --><P>The tracing parameters can be modified at runtime by assigning to the
following variables</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {
  CORBA::ULong   traceLevel;
  CORBA::Boolean traceExceptions;
  CORBA::Boolean traceInvocations;
  CORBA::Boolean traceInvocationReturns;
  CORBA::Boolean traceThreadId;
  CORBA::Boolean traceTime;
};</DIV><P>Log messages can be sent somewhere other than stderr by registering a
logging function which is called with the text of each log message:</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {
  <B>typedef</B> <B>void</B> (*logFunction)(<B>const</B> <B>char</B>*);
  <B>void</B> setLogFunction(logFunction f);
};</DIV><P>The log function must not make any CORBA calls, since that could lead
to infinite recursion as outputting a log message caused other log
messages to be generated, and so on.</P><!--TOC section Miscellaneous global options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc61">4.3</A>&#XA0;&#XA0;Miscellaneous global options</H2><!--SEC END --><P>These options control miscellaneous features that affect the whole ORB
runtime.</P><P><TT>dumpConfiguration</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If set <TT>true</TT>, the ORB dumps the values of all configuration
parameters at start-up.</P><P><TT>scanGranularity</TT> &#XA0;&#XA0; <I>default</I> =
<TT>5</TT></P><P>As explained in chapter&#XA0;<A HREF="#chap:connections">6</A>, omniORB regularly
scans incoming and outgoing connections, so it can close unused
ones. This value is the granularity in seconds at which the ORB
performs its scans. A value of zero turns off the scanning altogether.</P><P><TT>nativeCharCodeSet</TT> &#XA0;&#XA0; <I>default</I> =
<TT>ISO-8859-1</TT></P><P>The native code set the application is using for <TT>char</TT> and
<TT>string</TT>. See chapter&#XA0;<A HREF="#chap:codesets">8</A>.</P><P><TT>nativeWCharCodeSet</TT> &#XA0;&#XA0; <I>default</I> =
<TT>UTF-16</TT></P><P>The native code set the application is using for <TT>wchar</TT> and
<TT>wstring</TT>. See chapter&#XA0;<A HREF="#chap:codesets">8</A>.</P><P><TT>copyValuesInLocalCalls</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>Determines whether valuetype parameters in local calls are copied or
not. See chapter&#XA0;<A HREF="#chap:valuetype">11</A>.</P><P><TT>abortOnInternalError</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If this is set <TT>true</TT>, internal fatal errors will abort
immediately, rather than throwing the <TT>omniORB::fatalException</TT>
exception. This can be helpful for tracking down bugs, since it
leaves the call stack intact.</P><P><TT>abortOnNativeException</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>On Windows, &#X2018;native&#X2019; exceptions such as segmentation faults and divide
by zero appear as C++ exceptions that can be caught with <TT>catch
(...)</TT>. Setting this parameter to <TT>true</TT> causes such exceptions
to abort the process instead.</P><P><TT>maxSocketSend</TT><BR>
<TT>maxSocketRecv</TT><BR>

On some platforms, calls to send() and recv() have a limit on the
buffer size that can be used. These parameters set the limits in bytes
that omniORB uses when sending / receiving bulk data.</P><P>The default values are platform specific. It is unlikely that you will
need to change the values from the defaults.</P><P>The minimum valid limit is 1KB, 1024 bytes.</P><P><TT>socketSendBuffer</TT> &#XA0;&#XA0; <I>default</I> =
<TT>-1 </TT><TT><I>or</I></TT><TT> 16384</TT></P><P>On Windows, there is a kernel buffer used during send operations. A
bug in Windows means that if a send uses the entire kernel buffer, a
select() on the socket blocks until all the data has been acknowledged
by the receiver, resulting in dreadful performance. This parameter
modifies the socket send buffer from its default (8192 bytes on
Windows) to the value specified. If this parameter is set to -1, the
socket send buffer is left at the system default.</P><P>On Windows, the default value of this parameter is 16384 bytes; on all
other platforms the default is -1.</P><P><TT>validateUTF8</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>When transmitting a string that is supposed to be UTF-8, omniORB
usually passes it directly, assuming that it is valid. With this
parameter set <TT>true</TT>, omniORB checks that all UTF-8 strings are
valid, and throws DATA_CONVERSION if not.</P><!--TOC section Client side options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc62">4.4</A>&#XA0;&#XA0;Client side options</H2><!--SEC END --><P>
<A NAME="sec:clientconf"></A></P><P>These options control aspects of client-side behaviour.</P><P><TT>InitRef</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>Specify objects available from
<TT>ORB::resolve_initial_references()</TT>. The arguments take the form
&lt;<I>key</I>&gt;=&lt;<I>uri</I>&gt;, where <I>key</I> is the name given to
<TT>resolve_initial_references()</TT> and <I>uri</I> is a
valid CORBA object reference URI, as detailed in
chapter&#XA0;<A HREF="#chap:ins">7</A>.</P><P><TT>DefaultInitRef</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>Specify the default URI prefix for
<TT>resolve_initial_references()</TT>, as explained in
chapter&#XA0;<A HREF="#chap:ins">7</A>.</P><P><TT>clientTransportRule</TT> &#XA0;&#XA0; <I>default</I> =
<TT>* unix,tcp,ssl</TT></P><P>Used to specify the way the client contacts a server, depending on the
server&#X2019;s address. See section&#XA0;<A HREF="#sec:clientRule">6.7.1</A> for details.</P><P><TT>clientCallTimeOutPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>Call timeout in milliseconds for the client side. If a call takes
longer than the specified number of milliseconds, the ORB closes the
connection to the server and raises a <TT>TRANSIENT</TT> exception. A
value of zero means no timeout; calls can block for ever. See
section&#XA0;<A HREF="#sec:timeoutAPI">6.3.1</A> for more information about timeouts.</P><P><B>Note</B>: omniORB 3 had timeouts specified in seconds;
omniORB 4.0 and later use milliseconds for timeouts.</P><P><TT>clientConnectTimeOutPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>The timeout that is used in the case that a new network connection is
established to the server. A value of zero means that the normal call
timeout is used. See section&#XA0;<A HREF="#sec:timeoutAPI">6.3.1</A> for more information
about timeouts.</P><P><TT>supportPerThreadTimeOut</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If this parameter is set <TT>true</TT>, timeouts can be set on a per
thread basis, as well as globally and per object. Checking per-thread
storage has a noticeable performance impact, so it is turned off by
default.</P><P><TT>resetTimeoutOnRetries</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If <TT>true</TT>, the call timeout is reset when an exception handler
causes a call to be retried. If <TT>false</TT>, the timeout is not
reset, and therefore applies to the call as a whole, rather than to
each individual call attempt.</P><P><TT>throwTransientOnTimeout</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>omniORB 4.2 supports the <TT>CORBA::TIMEOUT</TT> exception that is part
of the CORBA Messaging specification. By default, that is the
exception thrown when timeouts occur. Previous omniORB releases did
not have the <TT>CORBA::TIMEOUT</TT> exception, and instead used
<TT>CORBA::TRANSIENT</TT>. If this parameter is set <TT>true</TT>, omniORB
follows the old behaviour of throwing <TT>CORBA::TRANSIENT</TT> when a
timeout occurs.</P><P><TT>outConScanPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>120</TT></P><P>Idle timeout in seconds for outgoing (i.e. client initiated)
connections. If a connection has been idle for this amount of time,
the ORB closes it. See section&#XA0;<A HREF="#sec:connShutdown">6.5</A>.</P><P><TT>maxGIOPConnectionPerServer</TT> &#XA0;&#XA0; <I>default</I> =
<TT>5</TT></P><P>The maximum number of concurrent connections the ORB will open to a
<EM>single</EM> server. If multiple threads on the client call the same
server, the ORB opens additional connections to the server, up to the
maximum specified by this parameter. If the maximum is reached,
threads are blocked until a connection becomes free for them to use.</P><P><TT>oneCallPerConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>When this parameter is set to <TT>true</TT> (the default), the ORB will
only send a single call on a connection at a time. If multiple client
threads invoke on the same server, multiple connections are opened, up
to the limit specified by
<TT>maxGIOPConnectionPerServer</TT>. With this parameter set to
<TT>false</TT>, the ORB will allow concurrent calls on a single
connection. This saves connection resources, but requires slightly
more management work for both client and server. Some server-side ORBs
(including omniORB versions before 4.0) serialise all incoming calls
on a single connection.</P><P><TT>maxInterleavedCallsPerConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>5</TT></P><P>The maximum number of calls that can be interleaved on a connection.
If more concurrent calls are made, they are queued.</P><P><TT>offerBiDirectionalGIOP</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If set <TT>true</TT>, the client will indicate to servers that it is
willing to accept callbacks on client-initiated connections using
bidirectional GIOP, provided the relevant POA policies are set. See
section&#XA0;<A HREF="#sec:bidir">6.8</A>.</P><P><TT>diiThrowsSysExceptions</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If this is <TT>true</TT>, DII functions throw system exceptions; if it
is <TT>false</TT>, system exceptions that occur are passed through the
<TT>Environment</TT> object.</P><P><TT>verifyObjectExistsAndType</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>By default, omniORB uses the GIOP <TT>LOCATE_REQUEST</TT> message to
verify the existence of an object prior to the first invocation. In
the case that the full type of the object is not known, it instead
calls the <TT>_is_a()</TT> operation to check the object&#X2019;s type. Some ORBs
have bugs that mean one or other of these operations fail. Setting
this parameter <TT>false</TT> prevents omniORB from making these calls.</P><P><TT>giopTargetAddressMode</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>GIOP 1.2 supports three addressing modes for contacting objects. This
parameter selects the mode that omniORB uses. A value of 0 means
<TT>GIOP::KeyAddr</TT>; 1 means <TT>GIOP::ProfileAddr</TT>; 2 means
<TT>GIOP::ReferenceAddr</TT>.</P><P><TT>immediateAddressSwitch</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If <TT>true</TT>, the client will immediately switch to use a new
address to contact an object after a failure. If <TT>false</TT> (the
default), the current address will be retried in certain
circumstances.</P><P><TT>bootstrapAgentHostname</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>If set, this parameter indicates the hostname to use for look-ups
using the obsolete Sun bootstrap agent. This mechanism is superseded
by the interoperable naming service.</P><P><TT>bootstrapAgentPort</TT> &#XA0;&#XA0; <I>default</I> =
<TT>900</TT></P><P>The port number for the obsolete Sun bootstrap agent.</P><P><TT>principal</TT> &#XA0;&#XA0; <I>default</I> =
<TT><I>none</I></TT></P><P>GIOP 1.0 and 1.1 have a request header field named &#X2018;principal&#X2019;, which
contains a sequence of octets. It was never defined what it should
mean, and its use is now deprecated; GIOP 1.2 has no such field. Some
systems (e.g. Gnome) use the principal field as a primitive
authentication scheme. This parameter sets the data omniORB uses in
the principal field. The default is an empty sequence.</P><!--TOC section Server side options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">4.5</A>&#XA0;&#XA0;Server side options</H2><!--SEC END --><P>These parameters affect server-side operations.</P><P><TT>endPoint&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;</TT> &#XA0;&#XA0; <I>default</I> = <TT>giop:tcp::</TT><BR>
<TT>endPointNoListen</TT><BR>
<TT>endPointPublish</TT><BR>
<TT>endPointNoPublish</TT><BR>
<TT>endPointPublishAllIFs</TT><BR>

These options determine the end-points the ORB should listen on, and
the details that should be published in IORs. See
chapter&#XA0;<A HREF="#chap:connections">6</A> for details.</P><P><TT>serverTransportRule</TT> &#XA0;&#XA0; <I>default</I> =
<TT>* unix,tcp,ssl</TT></P><P>Configure the rules about whether a server should accept an incoming
connection from a client. See section&#XA0;<A HREF="#sec:serverRule">6.7.2</A> for
details.</P><P><TT>serverCallTimeOutPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>This timeout is used to catch the situation that the server starts
receiving a request, but the end of the request never comes. If a
calls takes longer than the specified number of milliseconds to
arrive, the ORB shuts the connection. A value of zero means never
timeout.</P><P><TT>inConScanPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>180</TT></P><P>Idle timeout in seconds for incoming connections. If a connection has
been idle for this amount of time, the ORB closes it. See
section&#XA0;<A HREF="#sec:connShutdown">6.5</A>.</P><P><TT>threadPerConnectionPolicy</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>If <TT>true</TT> (the default), the ORB dedicates one server thread to
each incoming connection. Setting it <TT>false</TT> means the server
should use a thread pool.</P><P><TT>maxServerThreadPerConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>100</TT></P><P>If the client multiplexes several concurrent requests on a single
connection, omniORB uses extra threads to service them. This parameter
specifies the maximum number of threads that are allowed to service a
single connection at any one time.</P><P><TT>maxServerThreadPoolSize</TT> &#XA0;&#XA0; <I>default</I> =
<TT>100</TT></P><P>The maximum number of threads the server will allocate to do various
tasks, including dispatching calls in the thread pool mode. This
number does not include threads dispatched under the thread per
connection server mode.</P><P><TT>threadPerConnectionUpperLimit</TT> &#XA0;&#XA0; <I>default</I> =
<TT>10000</TT></P><P>If the <TT>threadPerConnectionPolicy</TT> parameter is <TT>true</TT>, the
ORB can automatically transition to thread pool mode if too many
connections arrive. This parameter sets the number of connections at
which thread pooling is started. The default of 10000 is designed to
mean that it never happens.</P><P><TT>threadPerConnectionLowerLimit</TT> &#XA0;&#XA0; <I>default</I> =
<TT>9000</TT></P><P>If thread pooling was started because the number of connections hit
the upper limit, this parameter determines when thread per connection
should start again.</P><P><TT>threadPoolWatchConnection</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>After dispatching an upcall in thread pool mode, the thread that has
just performed the call can watch the connection for a short time
before returning to the pool. This leads to less thread switching for
a series of calls from a single client, but is less fair if there are
concurrent clients. The connection is watched if the number of threads
concurrently handling the connection is less than or equal to the
value of this parameter. i.e. if the parameter is zero, the
connection is never watched; if it is 1, the last thread managing a
connection watches it; if 2, the connection is still watched if there
is one other thread still in an upcall for the connection, and so
on. See section&#XA0;<A HREF="#sec:watchConn">6.4.2</A>.</P><P><TT>connectionWatchPeriod</TT> &#XA0;&#XA0; <I>default</I> =
<TT>50000</TT></P><P>For each endpoint, the ORB allocates a thread to watch for new
connections and to monitor existing connections for calls that should
be handed by the thread pool. The thread blocks in select() or similar
for a period, after which it re-scans the lists of connections it
should watch. This parameter is specified in microseconds.</P><P><TT>connectionWatchImmediate</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>When a thread handles an incoming call, it unmarshals the arguments
then marks the connection as watchable by the connection watching
thread, in case the client sends a concurrent call on the same
connection. If this parameter is set to the default <TT>false</TT>, the
connection is not actually watched until the next connection watch
period (determined by the <TT>connectionWatchPeriod</TT> parameter). If
this parameter is set <TT>true</TT>, the connection watching thread is
immediately signalled to watch the connection. That leads to faster
interactive response to clients that multiplex calls, but adds
significant overhead along the call chain.</P><P>Note that this setting has no effect on Windows, since it has no
mechanism for signalling the connection watching thread.</P><P><TT>acceptBiDirectionalGIOP</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>Determines whether a server will ever accept clients&#X2019; offers of
bidirectional GIOP connections. See section&#XA0;<A HREF="#sec:bidir">6.8</A>.</P><P><TT>unixTransportDirectory</TT> &#XA0;&#XA0; <I>default</I> =
<TT>/tmp/omni-%u</TT></P><P>(Unix platforms only). Selects the location used to store Unix domain
sockets. The &#X2018;<TT>%u</TT>&#X2019; is expanded to the user name.</P><P><TT>unixTransportPermission</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0777</TT></P><P>(Unix platforms only). Determines the octal permission bits for Unix
domain sockets. By default, all users can connect to a server, just as
with TCP.</P><P><TT>supportCurrent</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>omniORB supports the <TT>PortableServer::Current</TT> interface to
provide thread context information to servants. Supporting current has
a small but noticeable run-time overhead due to accessing thread
specific storage, so this option allows it to be turned off.</P><P><TT>objectTableSize</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>Hash table size of the Active Object Map. If this is zero, the ORB
uses a dynamically resized open hash table. This is normally the best
option, but it leads to less predictable performance since any
operation which adds or removes a table entry may trigger a resize. If
set to a non-zero value, the hash table has the specified number of
entries, and is never resized. Note that the hash table is open, so
this does not limit the number of active objects, just how efficiently
they can be located.</P><P><TT>poaHoldRequestTimeout</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If a POA is put in the <TT>HOLDING</TT> state, calls to it will be timed
out after the specified number of milliseconds, by raising a
<TT>CORBA::TIMEOUT</TT> exception. Zero means no timeout.</P><P><TT>poaUniquePersistentSystemIds</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>The POA specification requires that object ids in POAs with the
PERSISTENT and SYSTEM_ID policies are unique between instantiations
of the POA. Older versions of omniORB did not comply with that, and
reused object ids. With this value <TT>true</TT>, the POA has the
correct behaviour; with <TT>false</TT>, the POA uses the old scheme for
compatibility.</P><P><TT>idleThreadTimeout</TT> &#XA0;&#XA0; <I>default</I> =
<TT>10</TT></P><P>When a thread created by omniORB becomes idle, it is kept alive for a
while, in case a new thread is required. Once a thread has been idle
for the number of seconds specified in this parameter, it exits.</P><P><TT>supportBootstrapAgent</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If set <TT>true</TT>, servers support the Sun bootstrap agent protocol.</P><!--TOC subsection Main thread selection-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc64">4.5.1</A>&#XA0;&#XA0;Main thread selection</H3><!--SEC END --><P>There is one server-side parameter that must be set with an API
function, rather than a normal configuration parameter:</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {
  <B>void</B> setMainThread();
};</DIV><P>POAs with the <TT>MAIN_THREAD</TT> policy dispatch calls on the &#X2018;main&#X2019;
thread. By default, omniORB assumes that the thread that initialised
the omnithread library is the &#X2018;main&#X2019; thread. To choose a different
thread, call this function from the desired &#X2018;main&#X2019; thread. The calling
thread must have an <TT>omni_thread</TT> associated with it (i.e. it
must have been created by omnithread, or
<TT>omni_thread::create_dummy()</TT> must have been called). If it
does not, the function throws <TT>CORBA::INITIALIZE</TT>.</P><P>Note that calls are only actually dispatched to the &#X2018;main&#X2019; thread if
<TT>ORB::run()</TT> or <TT>ORB::perform_work()</TT> is called from that thread.</P><!--TOC section GIOP and interoperability options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc65">4.6</A>&#XA0;&#XA0;GIOP and interoperability options</H2><!--SEC END --><P>These options control omniORB&#X2019;s use of GIOP, and cover some areas
where omniORB can work around buggy behaviour by other ORBs.</P><P><TT>maxGIOPVersion</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1.2</TT></P><P>Choose the maximum GIOP version the ORB should support. Valid values
are 1.0, 1.1 and 1.2.</P><P><TT>giopMaxMsgSize</TT> &#XA0;&#XA0; <I>default</I> =
<TT>2097152</TT></P><P>The largest message, in bytes, that the ORB will send or receive, to
avoid resource starvation. If the limit is exceeded, a <TT>MARSHAL</TT>
exception is thrown. The size must be &gt;= 8192.</P><P><TT>strictIIOP</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>If <TT>true</TT>, be strict about interpretation of the IIOP
specification; if <TT>false</TT>, permit some buggy behaviour to pass.</P><P><TT>lcdMode</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If <TT>true</TT>, select &#X2018;Lowest Common Denominator&#X2019; mode. This disables
various IIOP and GIOP features that are known to cause problems with
some ORBs.</P><P><TT>tcAliasExpand</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>This flag is used to indicate whether TypeCodes associated with Anys
should have aliases removed. This functionality is included because
some ORBs will not recognise an Any containing a TypeCode with aliases
to be the same as the actual type contained in the Any. There is a
performance penalty when inserting into an Any if <TT>tcAliasExpand</TT>
is set to 1.</P><P><TT>useTypeCodeIndirections</TT> &#XA0;&#XA0; <I>default</I> =
<TT>1</TT></P><P>TypeCode Indirections reduce the size of marshalled TypeCodes, and are
essential for recursive types, but some old ORBs do not support them.
Setting this flag to <TT>false</TT> prevents the use of indirections
(and, therefore, prevents the use of recursive TypeCodes).</P><P><TT>acceptMisalignedTcIndirections</TT> &#XA0;&#XA0; <I>default</I> =
<TT>0</TT></P><P>If <TT>true</TT>, try to fix a mis-aligned indirection in a
typecode. This is used to work around a bug in some old versions of
Visibroker&#X2019;s Java ORB.</P><!--TOC section System Exception Handlers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">4.7</A>&#XA0;&#XA0;System Exception Handlers</H2><!--SEC END --><P>By default, all system exceptions that are raised during an operation
invocation, with the exception of some cases of
<TT>CORBA::TRANSIENT</TT>, are propagated to the application code. Some
applications may prefer to trap these exceptions within the proxy
objects so that the application logic does not have to deal with the
error condition. For example, when a <TT>CORBA::COMM_FAILURE</TT> is
received, an application may just want to retry the invocation until
it finally succeeds. This approach is useful for objects that are
persistent and have idempotent operations.</P><P>omniORB provides a set of functions to install exception handlers.
Once they are installed, proxy objects will call these handlers when
the associated system exceptions are raised by the ORB runtime.
Handlers can be installed for <TT>CORBA::TRANSIENT</TT>,
<TT>CORBA::TIMEOUT</TT>, <TT>CORBA::COMM_FAILURE</TT> and
<TT>CORBA::SystemException</TT>. This last handler covers all
system exceptions other than the three specific ones covered by the
first three handlers. An exception handler can be installed for
individual proxy objects, or it can be installed for all proxy objects
in the address space.</P><!--TOC subsection Minor codes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">4.7.1</A>&#XA0;&#XA0;Minor codes</H3><!--SEC END --><P>omniORB makes extensive use of exception minor codes to indicate the
specific circumstances surrounding a system exception. The file
<TT>include/omniORB4/minorCode.h</TT> contains definitions of all the
minor codes used in omniORB, covering codes allocated in the CORBA
specification, and ones specific to omniORB. In compilers with
namespace support, the minor code constants appear in namespace
<TT>omni</TT>; otherwise they are in the global scope.</P><P>Applications can use minor codes to adjust their behaviour according
to the condition, e.g.</P><DIV CLASS="lstlisting"><B>try</B> {
  ...
}
<B>catch</B> (CORBA::TRANSIENT&amp; ex) {
  <B>if</B> (ex.minor() == omni::TRANSIENT_ConnectFailed) {
    <I>// retry with a different object reference...</I>
  }
  <B>else</B> {
    <I>// print an error message...</I>
  }
}</DIV><!--TOC subsection CORBA::TRANSIENT handlers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">4.7.2</A>&#XA0;&#XA0;CORBA::TRANSIENT handlers</H3><!--SEC END --><P><TT>TRANSIENT</TT> exceptions can occur in many circumstances. One
circumstance is as follows:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">The client invokes on an object reference.
</LI><LI CLASS="li-enumerate">The object replies with a <TT>LOCATION_FORWARD</TT> message.
</LI><LI CLASS="li-enumerate">The client caches the new location and retries to the new location.
</LI><LI CLASS="li-enumerate">Time passes...
</LI><LI CLASS="li-enumerate">The client tries to invoke on the object again, using the
cached, forwarded location. 
</LI><LI CLASS="li-enumerate">The attempt to contact the object fails.
</LI><LI CLASS="li-enumerate">The ORB runtime resets the location cache and throws a
<TT>TRANSIENT</TT> exception with minor code
<TT>TRANSIENT_FailedOnForwarded</TT>.</LI></OL><P>In this situation, the default <TT>TRANSIENT</TT> exception handler
retries the call, using the object&#X2019;s original location. If the retry
results in another <TT>LOCATION_FORWARD</TT>, to the same or a
different location, and <EM>that</EM> forwarded location fails
immediately, the <TT>TRANSIENT</TT> exception will occur again, and the
pattern will repeat. With repeated exceptions, the handler starts
adding delays before retries, with exponential back-off.</P><P>In all other circumstances, the default <TT>TRANSIENT</TT> handler just
passes the exception on to the caller.</P><P>Applications can override the default behaviour by installing their
own exception handler. The API to do so is summarised below:</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {

  <B>typedef</B> CORBA::Boolean
  (*transientExceptionHandler_t)(<B>void</B>* cookie,
                                 CORBA::ULong n_retries,
                                 <B>const</B> CORBA::TRANSIENT&amp; ex);

  <B>void</B>
  installTransientExceptionHandler(<B>void</B>* cookie,
                                   transientExceptionHandler_t fn);

  <B>void</B>
  installTransientExceptionHandler(CORBA::Object_ptr obj,
                                   <B>void</B>* cookie,
                                   transientExceptionHandler_t fn);
}</DIV><P>The overloaded <TT>installTransientExceptionHandler()</TT> function is used
to install the exception handlers for <TT>CORBA::TRANSIENT</TT>. Two
forms are available: the first form installs an exception handler for
all object references except for those which have an exception handler
installed by the second form, which takes an additional argument to
identify the target object reference. The argument <TT>cookie</TT> is an
opaque pointer which will be passed on by the ORB when it calls the
exception handler.</P><P>An exception handler will be called by proxy objects with three
arguments. The <TT>cookie</TT> is the opaque pointer registered by
<TT>installTransientExceptionHandler()</TT>. The argument
<TT>n_retries</TT> is the number of times the proxy has called this
handler for the same invocation. The argument <TT>ex</TT> is the value
of the exception caught. The exception handler is expected to do
whatever is appropriate and return a boolean value. If the return
value is <TT>true</TT>, the proxy object retries the operation. If the
return value is <TT>false</TT>, the original exception is propagated
into the application code. In the case of a <TT>TRANSIENT</TT> exception
due to a failed location forward, the exception propagated to the
application is the <EM>original</EM> exception that caused the
<TT>TRANSIENT</TT> (e.g. a <TT>COMM_FAILURE</TT> or
<TT>OBJECT_NOT_EXIST</TT>), rather than the <TT>TRANSIENT</TT>
exception<SUP><A NAME="text10" HREF="#note10">1</A></SUP>.</P><P>The following sample code installs a simple exception handler for all
objects and for a specific object:</P><DIV CLASS="lstlisting">CORBA::Boolean my_transient_handler1(<B>void</B>* cookie,
                                     CORBA::ULong retries,
                                     <B>const</B> CORBA::TRANSIENT&amp; ex)
{
   cerr &lt;&lt; "transient handler 1 called." &lt;&lt; endl;
   <B>return</B> <B>true</B>;           <I>// retry immediately.</I>
}

CORBA::Boolean my_transient_handler2(<B>void</B>* cookie,
                                     CORBA::ULong retries,
                                     <B>const</B> CORBA::TRANSIENT&amp; ex)
{
   cerr &lt;&lt; "transient handler 2 called." &lt;&lt; endl;
   <B>return</B> <B>false</B>;          <I>// do not retry.</I>
}


<B>static</B> Echo_ptr myobj;

<B>void</B> installhandlers()
{
   omniORB::installTransientExceptionHandler(0, my_transient_handler1);
   <I>// All proxy objects will call my_transient_handler1 from now on.</I>

   omniORB::installTransientExceptionHandler(myobj, 0, my_transient_handler2);
   <I>// The proxy object of myobj will call my_transient_handler2 from now on.</I>
}</DIV><!--TOC subsection CORBA::TIMEOUT-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">4.7.3</A>&#XA0;&#XA0;CORBA::TIMEOUT</H3><!--SEC END --><P>When a call timeout occurs, by default the ORB throws
<TT>CORBA::TIMEOUT</TT>. The default behaviour of the proxy objects is
to propagate this exception to the application. Applications can
override the default behaviour by installing their own exception
handlers. The API to do so is summarised below:</P><DIV CLASS="lstlisting"><B>typedef</B> CORBA::Boolean
(*timeoutExceptionHandler_t)(<B>void</B>* cookie,
                             CORBA::ULong n_retries,
                             <B>const</B> CORBA::TIMEOUT&amp; ex);

<B>void</B>
installTimeoutExceptionHandler(<B>void</B>* cookie,
                               timeoutExceptionHandler_t fn);

<B>void</B>
installTimeoutExceptionHandler(CORBA::Object_ptr obj,
                               <B>void</B>* cookie,
                               timeoutExceptionHandler_t fn);</DIV><P>The functions are equivalent to their counterparts for
<TT>CORBA::TRANSIENT</TT>.</P><P>omniORB version 4.1 and earlier did not have the <TT>CORBA::TIMEOUT</TT>
exception, and threw <TT>CORBA::TRANSIENT</TT> instead. If the
<TT>throwTransientOnTimeout</TT> configuration parameter is set to
<TT>1</TT>, omniORB 4.2 reverts to this behaviour, and calls the
transient exception handler instead of the timeout exception handler.</P><P>The timeout exception handler is used when a CORBA call times out. It
is <EM>not</EM> called when an AMI poller operation throws
<TT>CORBA::TIMEOUT</TT>. In that situation, the exception is always
propagated to the caller.</P><!--TOC subsection CORBA::COMM_FAILURE-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">4.7.4</A>&#XA0;&#XA0;CORBA::COMM_FAILURE</H3><!--SEC END --><P>If the ORB has successfully contacted a server at some point, and
access to it subsequently fails (and the condition for
<TT>TRANSIENT</TT> described above does not occur), the ORB raises a
<TT>CORBA::COMM_FAILURE</TT> exception.</P><P>The default behaviour of the proxy objects is to propagate this
exception to the application. Applications can override the default
behaviour by installing their own exception handlers. The API to do so
is summarised below:</P><DIV CLASS="lstlisting"><B>typedef</B> CORBA::Boolean
(*commFailureExceptionHandler_t)(<B>void</B>* cookie,
                                 CORBA::ULong n_retries,
                                 <B>const</B> CORBA::COMM_FAILURE&amp; ex);

<B>void</B>
installCommFailureExceptionHandler(<B>void</B>* cookie,
                                   commFailureExceptionHandler_t fn);

<B>void</B>
installCommFailureExceptionHandler(CORBA::Object_ptr obj,
                                   <B>void</B>* cookie,
                                   commFailureExceptionHandler_t fn);</DIV><P>The functions are equivalent to their counterparts for
<TT>CORBA::TRANSIENT</TT>.</P><!--TOC subsection CORBA::SystemException-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">4.7.5</A>&#XA0;&#XA0;CORBA::SystemException</H3><!--SEC END --><P>If a system exceptions other than <TT>TRANSIENT</TT>, <TT>TIMEOUT</TT> or
<TT>COMM_FAILURE</TT> occurs, the default behaviour of the proxy
objects is to propagate this exception to the application.
Applications can override the default behaviour by installing their
own exception handlers. The API to do so is summarised below:</P><DIV CLASS="lstlisting"><B>typedef</B> CORBA::Boolean
(*systemExceptionHandler_t)(<B>void</B>* cookie,
                            CORBA::ULong n_retries,
                            <B>const</B> CORBA::SystemException&amp; ex);

<B>void</B>
installSystemExceptionHandler(<B>void</B>* cookie,
                              systemExceptionHandler_t fn);

<B>void</B>
installSystemExceptionHandler(CORBA::Object_ptr obj,
                              <B>void</B>* cookie,
                              systemExceptionHandler_t fn);</DIV><P>The functions are equivalent to their counterparts for
<TT>CORBA::TRANSIENT</TT>.</P><!--TOC subsection Extended exception handlers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">4.7.6</A>&#XA0;&#XA0;Extended exception handlers</H3><!--SEC END --><P>New in omniORB 4.2, each of the exception handlers described above
also has an &#X2018;extended&#X2019; form in which the exception handler takes two
additional parameters, the object reference being invoked upon, and a
string containing the name of the operation invoked. e.g.:</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {

  <B>typedef</B> CORBA::Boolean
  (*transientExceptionHandlerExt_t)(<B>void</B>*                   cookie,
                                    CORBA::ULong            n_retries,
                                    <B>const</B> CORBA::TRANSIENT&amp; ex,
                                    CORBA::Object_ptr       obj,
                                    <B>const</B> <B>char</B>*             op);

  <B>void</B>
  installTransientExceptionHandlerExt(<B>void</B>* cookie,
                                     transientExceptionHandlerExt_t fn);

  <B>void</B>
  installTransientExceptionHandlerExt(CORBA::Object_ptr obj,
                                      <B>void</B>* cookie,
                                      transientExceptionHandlerExt_t fn);
}</DIV><P>Note that the operation parameter can sometimes be null. By default,
omniORB sends a <TT>LocateRequest</TT> message prior to the first
operation invocation on an object reference. That <TT>LocateRequest</TT>
is subject to the same exception handling mechanism as a normal
operation invocation, but it is represented with a null operation
name. Exception handler code that uses the operation name must
correctly handle a null operation name pointer.</P><!--TOC section Location forwarding-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc73">4.8</A>&#XA0;&#XA0;Location forwarding</H2><!--SEC END --><P>
<A NAME="sec:locationForward"></A></P><P>Any CORBA operation invocation can return a <TT>LOCATION_FORWARD</TT>
message to the caller, indicating that it should retry the invocation
on a new object reference. The standard allows ServantManagers to
trigger <TT>LOCATION_FORWARD</TT>s by raising the
<TT>PortableServer::ForwardRequest</TT> exception, but it does not
provide a similar mechanism for normal servants. omniORB provides the
<TT>omniORB::LOCATION_FORWARD</TT> exception for this purpose. It
can be thrown by any operation implementation.</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {
  <B>class</B> LOCATION_FORWARD {
  <B>public</B>:
    LOCATION_FORWARD(CORBA::Object_ptr objref);
  };
};</DIV><P>The exception object consumes the object reference it is
passed.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note10" HREF="#text10">1</A></DT><DD CLASS="dd-thefootnotes">This is different from omniORB 4.0 and earlier,
where it was the <TT>TRANSIENT</TT> exception that was propagated to
the application.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter The IDL compiler-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc74">Chapter&#XA0;5</A>&#XA0;&#XA0;The IDL compiler</H1><!--SEC END --><P>
<A NAME="chap:omniidl"></A></P><P>omniORB&#X2019;s IDL compiler is called omniidl. It consists of a generic
front-end parser written in C++, and a number of back-ends written in
Python. omniidl is very strict about IDL validity, so you may find
that it reports errors in IDL which compiles fine with other IDL
compilers.</P><P>The general form of an omniidl command line is:</P><BLOCKQUOTE CLASS="quote"> <TT>omniidl </TT>[<I>options</I>]<TT> -b</TT>&lt;<I>back-end</I>&gt;<TT> </TT>[<I>back-end options</I>]<TT> </TT>&lt;<I>file</I>&gt;
</BLOCKQUOTE><!--TOC section Common options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc75">5.1</A>&#XA0;&#XA0;Common options</H2><!--SEC END --><P>The following options are common to all back-ends:</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-b</TT><I>back-end</I></TD><TD ALIGN=left NOWRAP>Run the specified back-end. For the C++ ORB, use <TT>-bcxx</TT>.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-D</TT><I>name</I>[<TT>=</TT><I>value</I>]</TD><TD ALIGN=left NOWRAP>Define <I>name</I> for the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-U</TT><I>name</I></TD><TD ALIGN=left NOWRAP>Undefine <I>name</I> for the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-I</TT><I>dir</I></TD><TD ALIGN=left NOWRAP>Include <I>dir</I> in the preprocessor search path.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-E</TT></TD><TD ALIGN=left NOWRAP>Only run the preprocessor, sending its output to stdout.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Y</TT><I>cmd</I></TD><TD ALIGN=left NOWRAP>Use <I>cmd</I> as the preprocessor, rather than the normal C
preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-N</TT></TD><TD ALIGN=left NOWRAP>Do not run the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-T</TT></TD><TD ALIGN=left NOWRAP>Use a temporary file, not a pipe, for preprocessor output.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wp</TT><I>arg</I>[,<I>arg</I>&#X2026;]</TD><TD ALIGN=left NOWRAP>Send arguments to the preprocessor.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wb</TT><I>arg</I>[,<I>arg</I>&#X2026;]</TD><TD ALIGN=left NOWRAP>Send arguments to the back-end.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-nf</TT></TD><TD ALIGN=left NOWRAP>Do not warn about unresolved forward declarations.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-k</TT></TD><TD ALIGN=left NOWRAP>Keep comments after declarations, to be used by some back-ends.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-K</TT></TD><TD ALIGN=left NOWRAP>Keep comments before declarations, to be used by some back-ends.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-C</TT><I>dir</I></TD><TD ALIGN=left NOWRAP>Change directory to <I>dir</I> before writing output files.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-d</TT></TD><TD ALIGN=left NOWRAP>Dump the parsed IDL then exit, without running a back-end.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-p</TT><I>dir</I></TD><TD ALIGN=left NOWRAP>Use <I>dir</I> as a path to find omniidl back-ends.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-V</TT></TD><TD ALIGN=left NOWRAP>Print version information then exit.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-u</TT></TD><TD ALIGN=left NOWRAP>Print usage information.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-v</TT></TD><TD ALIGN=left NOWRAP>Verbose: trace compilation stages.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
</TD></TR>
</TABLE><P>Most of these options are self explanatory, but some are not
so obvious.</P><!--TOC subsection Preprocessor interactions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc76">5.1.1</A>&#XA0;&#XA0;Preprocessor interactions</H3><!--SEC END --><P>IDL is processed by the C preprocessor before omniidl parses it.
omniidl always uses the GNU C preprocessor (which it builds with the
name omnicpp). The <TT>-D</TT>, <TT>-U</TT>, and <TT>-I</TT>
options are just sent to the preprocessor. Note that the current
directory is not on the include search path by default&#X2014;use
&#X2018;<TT>-I.</TT>&#X2019; for that. The <TT>-Y</TT> option can be used to
specify a different preprocessor to omnicpp. Beware that line
directives inserted by other preprocessors are likely to confuse
omniidl.</P><!--TOC subsubsection Ancient history: Windows 9x-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc77">5.1.1.1</A>&#XA0;&#XA0;Ancient history: Windows 9x</H4><!--SEC END --><P>The output from the C preprocessor is normally fed to the omniidl
parser through a pipe. On some Windows 98 machines (but not all!) the
pipe does not work, and the preprocessor output is echoed to the
screen. When this happens, the omniidl parser sees an empty file, and
produces useless stub files with strange long names. To avoid the
problem, use the &#X2018;<TT>-T</TT>&#X2019; option to create a temporary file
between the two stages.</P><!--TOC subsection Forward-declared interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">5.1.2</A>&#XA0;&#XA0;Forward-declared interfaces</H3><!--SEC END --><P>If you have an IDL file like:</P><DIV CLASS="lstlisting"><B>interface</B> I;
<B>interface</B> J {
  <B>attribute</B> I the_I;
};</DIV><P>then omniidl will normally issue a warning:</P><PRE CLASS="verbatim">  test.idl:1: Warning: Forward declared interface `I' was never
  fully defined
</PRE><P>It is illegal to declare such IDL in isolation, but it
<EM>is</EM> valid to define interface <TT>I</TT> in a separate file. If
you have a lot of IDL with this sort of construct, you will drown
under the warning messages. Use the <TT>-nf</TT> option to suppress
them.</P><!--TOC subsection Comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc79">5.1.3</A>&#XA0;&#XA0;Comments</H3><!--SEC END --><P>By default, omniidl discards comments in the input IDL. However, with
the <TT>-k</TT> and <TT>-K</TT> options, it preserves the comments
for use by the back-ends. The C++ back-end ignores this information,
but it is relatively easy to write new back-ends which <EM>do</EM> make
use of comments.</P><P>The two different options relate to how comments are attached to
declarations within the IDL. Given IDL like:</P><DIV CLASS="lstlisting"><B>interface</B> I {
  <B>void</B> op1();
  <I>// A comment</I>
  <B>void</B> op2();
};</DIV><P>the <TT>-k</TT> flag will attach the comment to <TT>op1()</TT>;
the <TT>-K</TT> flag will attach it to <TT>op2()</TT>.</P><!--TOC section C++ back-end options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc80">5.2</A>&#XA0;&#XA0;C++ back-end options</H2><!--SEC END --><P>
<A NAME="sec:cxx_backend"></A></P><P>When you specify the C++ back-end (with <TT>-bcxx</TT>), the
following <TT>-Wb</TT> options are available. Note that the
<TT>-Wb</TT> options must be specified <EM>after</EM> the
<TT>-bcxx</TT> option, so omniidl knows which back-end to give the
arguments to.</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbh=</TT><I>suffix</I></TD><TD ALIGN=left NOWRAP>Use <I>suffix</I> for generated header files. Default
&#X2018;<TT>.hh</TT>&#X2019;.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbs=</TT><I>suffix</I></TD><TD ALIGN=left NOWRAP>Use <I>suffix</I> for generated stub files. Default
&#X2018;<TT>SK.cc</TT>.&#X2019;</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbd=</TT><I>suffix</I></TD><TD ALIGN=left NOWRAP>Use <I>suffix</I> for generated dynamic files. Default
&#X2018;<TT>DynSK.cc</TT>.&#X2019;</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wba</TT></TD><TD ALIGN=left NOWRAP>Generate stubs for TypeCode and Any.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbtp</TT></TD><TD ALIGN=left NOWRAP>Generate &#X2018;tie&#X2019; implementation skeletons.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbtf</TT></TD><TD ALIGN=left NOWRAP>Generate flattened &#X2018;tie&#X2019; implementation skeletons.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbami</TT></TD><TD ALIGN=left NOWRAP>Generate AMI types and operations.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbexample</TT></TD><TD ALIGN=left NOWRAP>Generate example implementation code.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbinline</TT></TD><TD ALIGN=left NOWRAP>Output stubs for <TT>#include</TT>d IDL files in line with the
main file.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbuse-quotes</TT></TD><TD ALIGN=left NOWRAP>Use quotes in &#X2018;<TT>#include</TT>&#X2019; directives 
(e.g. <TT>"foo"</TT> rather than <TT>&lt;foo&gt;</TT>.)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbkeep-inc-path</TT></TD><TD ALIGN=left NOWRAP>Preserve IDL &#X2018;<TT>#include</TT>&#X2019; paths in generated
	&#X2018;<TT>#include</TT>&#X2019; directives.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbvirtual-objref</TT></TD><TD ALIGN=left NOWRAP>Use virtual functions for object reference operations.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbimpl-mapping</TT></TD><TD ALIGN=left NOWRAP>Use the &#X2018;implementation&#X2019; mapping for object reference methods.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbsplice-modules</TT></TD><TD ALIGN=left NOWRAP>Splice together multiply-opened modules into one.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-WbBOA</TT></TD><TD ALIGN=left NOWRAP>Generate BOA compatible skeletons.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbold</TT></TD><TD ALIGN=left NOWRAP>Generate old CORBA 2.1 signatures for skeletons.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-Wbold-prefix</TT></TD><TD ALIGN=left NOWRAP>Map C++ reserved words with prefix &#X2018;<TT>_</TT>&#X2019; rather than
&#X2018;<TT>_cxx_</TT>&#X2019;.</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>-WbF</TT></TD><TD ALIGN=left NOWRAP>Generate code fragments (only for use during omniORB build).</TD></TR>
<TR><TD ALIGN=left NOWRAP>
</TD></TR>
</TABLE><!--TOC subsection Optional code generation options-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">5.2.1</A>&#XA0;&#XA0;Optional code generation options</H3><!--SEC END --><P>By default, omniidl generates the minimum code required to provide all
the IDL-defined types and interfaces, which is sufficient for the
majority of applications. Additional code can also be generated, for
various purposes:</P><!--TOC subsubsection Any and TypeCode-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc82">5.2.1.1</A>&#XA0;&#XA0;Any and TypeCode</H4><!--SEC END --><P>To generate TypeCodes and Any insertion operators, give the
<TT>-Wba</TT> option. See chapter&#XA0;<A HREF="#chap:any">10</A> for details.</P><P>By default, omniidl separates the normal stub and skeleton file (the
<TT>SK.cc</TT> file) from these &#X2018;dynamic&#X2019; stubs (the <TT>DynSK.cc</TT>
file), so applications that do not need support for Any and TypeCode
for a particular IDL file do not waste space with unnecessary
definitions. It is possible to output both the normal stubs and the
dynamic stubs to a single file, by simply specifying the same
extension for both files. This command places both the normal stubs
and the dynamic stubs in <TT>aSK.cc</TT>:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bcxx -Wba -Wbd=SK.cc a.idl</TT>
</BLOCKQUOTE><!--TOC subsubsection Tie templates-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc83">5.2.1.2</A>&#XA0;&#XA0;Tie templates</H4><!--SEC END --><P>As described in section&#XA0;<A HREF="#sec:tie">2.11</A>, tie templates can be used to
provide servant implementations, instead of using inheritance from the
normal skeleton classes. To generate tie templates, give the
<TT>-Wbtp</TT> option to omniidl.</P><P>When using a pre-namespace C++ compiler, IDL modules are mapped to C++
classes, which causes a problem with tie templates. The C++ mapping
says that for the interface <TT>M::I</TT>, the C++ tie template class
should be named <TT>POA_M::I_tie</TT>. However, since template classes
cannot be declared inside other classes, this naming scheme cannot be
used if <TT>POA_M</TT> is a class.</P><P>The C++ mapping has an alternative option of &#X2018;flattened&#X2019; tie class
names, in which the template class is declared at global scope with
the name <TT>POA_M_I_tie</TT>. i.e. all occurrences of &#X2018;<TT>::</TT>&#X2019;
are replaced by &#X2018;<TT>_</TT>&#X2019;. Generate the flattened ties using the
<TT>-Wbtf</TT> command line argument.</P><!--TOC subsubsection Asynchronous Method Invocation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc84">5.2.1.3</A>&#XA0;&#XA0;Asynchronous Method Invocation</H4><!--SEC END --><P>Generate asynchronous invocation operations and the various types
required by AMI by specifying <TT>-Wbami</TT>. See
chapter&#XA0;<A HREF="#chap:ami">12</A> for details.</P><!--TOC subsubsection Example implementations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc85">5.2.1.4</A>&#XA0;&#XA0;Example implementations</H4><!--SEC END --><P>If you use the <TT>-Wbexample</TT> flag, omniidl will generate an
example implementation file as well as the stubs and skeletons. For
IDL file <TT>foo.idl</TT>, the example code is written to
<TT>foo_i.cc</TT>. The example file contains class and method
declarations for the operations of all interfaces in the IDL file,
along with a <TT>main()</TT> function which creates an instance of each
object. You still have to fill in the operation implementations, of
course.</P><!--TOC subsection Include file options-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">5.2.2</A>&#XA0;&#XA0;Include file options</H3><!--SEC END --><P>IDL files regularly <TT>#include</TT> other files. By default, if file
<TT>a.idl</TT> says <TT>#include &lt;b/c.idl&gt;</TT> then the generated
header <TT>a.hh</TT> has an include of the form <TT>#include
&lt;c.idl&gt;</TT>, and <TT>aSK.cc</TT> and <TT>aDynSK.cc</TT> contain only code
corresponding to the declarations in <TT>a.idl</TT>.</P><P>If the <TT>-Wbinline</TT> option is provided, all the
<TT>#include</TT>d declarations are generated in <TT>a.hh</TT>,
<TT>aSK.cc</TT> and <TT>aDynSK.cc</TT>, meaning the application code
should only use that single set of files.</P><P>If <TT>-Wbuse-quotes</TT> is specified, then the directive in
<TT>a.hh</TT> uses quotes rather than angle brackets:
<TT>#include "c.idl"</TT>.</P><P>Normally any path details contained in the IDL <TT>#include</TT>
directive are removed, leaving just the base name. If
<TT>-Wbkeep-inc-path</TT> is specified, the directive in
<TT>a.hh</TT> is <TT>#include &lt;b/c.idl&gt;</TT>.</P><!--TOC subsection Object reference operations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">5.2.3</A>&#XA0;&#XA0;Object reference operations</H3><!--SEC END --><P>Some of the C++ mapping&#X2019;s parameter passing rules are problematic in
terms of memory management. For example, if an IDL operation has a
parameter of type <TT>inout string</TT>, the standard mapping has a C++
parameter of type <TT>char*&amp;</TT>. If application code passes a
<TT>String_var</TT> for the parameter, some C++ compilers choose the
wrong conversion operator and cause a violation of the memory
management rules<SUP><A NAME="text11" HREF="#note11">1</A></SUP>.</P><P>To avoid this, omniORB uses some helper classes as the parameter types
in object reference operations, meaning that the correct memory
management rules are always followed. Normally, that is invisible to
application code, but occasionally it becomes problematic. One example
is that if a <TT>local interface</TT> is derived from a normal
unconstrained interface, the C++ mapping of the local interface
derives from the object reference class, and so the base object
reference class must use the standard mapping rather than omniORB&#X2019;s
usual enhanced mapping. To choose the standard &#X2018;implementation
mapping&#X2019;, give the <TT>-Wbimpl-mapping</TT> option to omniidl.</P><P>Similarly, omniidl usually uses non-virtual methods in its object
reference classes, since there is no usual need to override them. The
local interface situation also requires method overrides, so omniidl
must be instructed to generate object references as virtual. Use
<TT>-Wbvirtual-objref</TT> to achieve this.</P><P>More details about the local interface mapping can be found in
section&#XA0;<A HREF="#sec:LocalInterfaces">11.8</A>.</P><!--TOC subsection Module splicing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">5.2.4</A>&#XA0;&#XA0;Module splicing</H3><!--SEC END --><P>On ancient C++ compilers without namespace support, IDL modules map to
C++ classes, and so cannot be reopened. For some IDL, it is possible
to &#X2018;splice&#X2019; reopened modules on to the first occurrence of the module,
so all module definitions are in a single class. It is possible in
this sort of situation:</P><DIV CLASS="lstlisting"><B>module</B> M1 {
  <B>interface</B> I {};
};
<B>module</B> M2 {
  <B>interface</B> J {
    <B>attribute</B> M1::I ok;
  };
};
<B>module</B> M1 {
  <B>interface</B> K {
    <B>attribute</B> I still_ok;
  };
};</DIV><P>but not if there are cross-module dependencies:</P><DIV CLASS="lstlisting"><B>module</B> M1 {
  <B>interface</B> I {};
};
<B>module</B> M2 {
  <B>interface</B> J {
    <B>attribute</B> M1::I ok;
  };
};
<B>module</B> M1 {
  <B>interface</B> K {
    <B>attribute</B> M2::J oh_dear;
  };
};</DIV><P>In both of these cases, the <TT>-Wbsplice-modules</TT>
option causes omniidl to put all of the definitions for module
<TT>M1</TT> into a single C++ class. For the first case, this will work
fine. For the second case, class <TT>M1::K</TT> will contain a reference
to <TT>M2::J</TT>, which has not yet been defined; the C++ compiler will
complain.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc89">5.3</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>Generate the C++ headers and stubs for a file <TT>a.idl</TT>:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bcxx a.idl</TT>
</BLOCKQUOTE><P>Generate with Any support:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bcxx -Wba a.idl</TT>
</BLOCKQUOTE><P>As above, but also generate Python stubs (assuming omniORBpy
is installed):</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bcxx -Wba -bpython a.idl</TT>
</BLOCKQUOTE><P>Just check the IDL files for validity, generating no output:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl a.idl b.idl</TT>
</BLOCKQUOTE><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note11" HREF="#text11">1</A></DT><DD CLASS="dd-thefootnotes">For this reason, the <TT>_var</TT> types
define an <TT>inout()</TT> method that ensures use of the correct
conversion and thus avoids this kind of trouble.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Connection and Thread Management-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc90">Chapter&#XA0;6</A>&#XA0;&#XA0;Connection and Thread Management</H1><!--SEC END --><P>
<A NAME="chap:connections"></A></P><P>This chapter describes how omniORB manages threads and network
connections.</P><!--TOC section Background-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">6.1</A>&#XA0;&#XA0;Background</H2><!--SEC END --><P>In CORBA, the ORB is the &#X2018;middleware&#X2019; that allows a client to invoke
an operation on an object without regard to its implementation or
location. In order to invoke an operation on an object, a client needs
to &#X2018;bind&#X2019; to the object by acquiring its object reference. Such a
reference may be obtained as the result of an operation on another
object (such as a naming service or factory object) or by conversion
from a stringified representation. If the object is in a different
address space, the binding process involves the ORB building a proxy
object in the client&#X2019;s address space. The ORB arranges for invocations
on the proxy object to be transparently mapped to equivalent
invocations on the implementation object.</P><P>For the sake of interoperability, CORBA mandates that all ORBs should
support IIOP as the means to communicate remote invocations over a
TCP/IP connection. IIOP is usually<SUP><A NAME="text12" HREF="#note12">1</A></SUP>
asymmetric with respect to the roles of the parties at the two ends of
a connection. At one end is the client which can only initiate remote
invocations. At the other end is the server which can only receive
remote invocations.</P><P>Notice that in CORBA, as in most distributed systems, remote bindings
are established implicitly without application intervention. This
provides the illusion that all objects are local, a property known as
&#X2018;location transparency&#X2019;. CORBA does not specify when such bindings
should be established or how they should be multiplexed over the
underlying network connections. Instead, ORBs are free to implement
implicit binding by a variety of means.</P><P>The rest of this chapter describes how omniORB manages network
connections and the programming interface to fine tune the management
policy.</P><!--TOC section The model-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc92">6.2</A>&#XA0;&#XA0;The model</H2><!--SEC END --><P>omniORB is designed from the ground up to be fully multi-threaded. The
objective is to maximise the degree of concurrency and at the same
time eliminate any unnecessary thread overhead. Another objective is
to minimise the interference by the activities of other threads on the
progress of a remote invocation. In other words, thread &#X2018;cross-talk&#X2019;
should be minimised within the ORB. To achieve these objectives, the
degree of multiplexing at every level is kept to a minimum by default.</P><P>Minimising multiplexing works well when the system is relatively
lightly loaded. However, when the ORB is under heavy load, it can
sometimes be beneficial to conserve operating system resources such as
threads and network connections by multiplexing at the ORB
level. omniORB has various options that control its multiplexing
behaviour.</P><!--TOC section Client side behaviour-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc93">6.3</A>&#XA0;&#XA0;Client side behaviour</H2><!--SEC END --><P>On the client side of a connection, the thread that invokes on a proxy
object drives the GIOP protocol directly and blocks on the connection
to receive the reply. The first time the client makes a call to a
particular address space, the ORB opens a suitable connection to the
remote address space (based on the client transport rule as described
in section&#XA0;<A HREF="#sec:clientRule">6.7.1</A>). After the reply has been received,
the ORB caches the open network connection, ready for use by another
call.</P><P>If two (or more) threads in a multi-threaded client attempt to contact
the same address space simultaneously, there are two different ways to
proceed. The default way is to open another network connection to the
server. This means that neither the client or server ORB has to
perform any multiplexing on the network connections&#X2014;multiplexing is
performed by the operating system, which has to deal with multiplexing
anyway. The second possibility is for the client to multiplex the
concurrent requests on a single network connection. This conserves
operating system resources (network connections), but means that both
the client and server have to deal with multiplexing issues
themselves.</P><P>In the default one call per connection mode, there is a limit to the
number of concurrent connections that are opened, set with the
<TT>maxGIOPConnectionPerServer</TT> parameter. To tell the ORB
that it may multiplex calls on a single connection, set the
<TT>oneCallPerConnection</TT> parameter to zero. If the
<TT>oneCallPerConnection</TT> parameter is set to the default
value of one, and there are more concurrent calls than specified by
<TT>maxGIOPConnectionPerServer</TT>, calls block waiting for connections
to become free.</P><P>Note that some server-side ORBs, including omniORB versions before
version 4.0, are unable to deal with concurrent calls multiplexed on a
single connection, so they serialise the calls. It is usually best to
keep to the default mode of opening multiple connections.</P><!--TOC subsection Client side timeouts-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">6.3.1</A>&#XA0;&#XA0;Client side timeouts</H3><!--SEC END --><P>
<A NAME="sec:timeoutAPI"></A></P><P>omniORB can associate a timeout with a call, meaning that if the call
takes too long a <TT>CORBA::TIMEOUT</TT> exception<SUP><A NAME="text13" HREF="#note13">2</A></SUP> is
thrown. Timeouts can be set for the whole process, for a specific
thread, or for a specific object reference.</P><P>Timeouts are set using this API:</P><DIV CLASS="lstlisting"><B>namespace</B> omniORB {
  <B>void</B> setClientCallTimeout(CORBA::ULong millisecs);
  <B>void</B> setClientCallTimeout(CORBA::Object_ptr obj, CORBA::ULong millisecs);
  <B>void</B> setClientThreadCallTimeout(CORBA::ULong millisecs);
  <B>void</B> setClientConnectTimeout(CORBA::ULong millisecs);
};</DIV><P><TT>setClientCallTimeout()</TT> sets either the global timeout or the
timeout for a specific object reference.
<TT>setClientThreadCallTimeout()</TT> sets the timeout for the calling
thread. The calling thread must have an <TT>omni_thread</TT> associated
with it. Setting any timeout value to zero disables it.</P><P>Accessing per-thread state is a relatively expensive operation, so per
thread timeouts are disabled by default. The
<TT>supportPerThreadTimeOut</TT> parameter must be set <TT>true</TT> to
enable them.</P><P>To choose the timeout value to use for a call, the ORB first looks to
see if there is a timeout for the object reference, then to the
calling thread, and finally to the global timeout.</P><P>When a client has no existing connection to communicate with a server,
it must open a new connection before performing the
call. <TT>setClientConnectTimeout()</TT> sets an overriding timeout for
cases where a new connection must be established. The effect of the
connect timeout depends upon whether the connect timeout is greater
or less than the timeout that would otherwise be used.</P><P>As an example, imagine that the usual call timeout is 10 seconds:</P><!--TOC subsubsection Connect timeout &gt; usual timeout-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Connect timeout &gt; usual timeout</H4><!--SEC END --><P>If the connect timeout is set to 20 seconds, then a call that
establishes a new connection will be permitted 20 seconds before it
times out. Subsequent calls using the same connection have the normal
10 second timeout. If establishing the connection takes 8 seconds,
then the call itself takes 5 seconds, the call succeeds despite having
taken 13 seconds in total, longer than the usual timeout.</P><P>This kind of configuration is good when connections are slow to be
established.</P><P>If an object reference has multiple possible endpoints available, and
connecting to the first endpoint times out, only that one endpoint
will have been tried before an exception is raised. However, once the
timeout has occurred, the object reference will switch to use the next
endpoint. If the application attempts to make another call, it will
use the next endpoint.</P><!--TOC subsubsection Connect timeout &lt; usual timeout-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Connect timeout &lt; usual timeout</H4><!--SEC END --><P>If the connect timeout is set to 2 seconds, the actual network-level
connect is only permitted to take 2 seconds. As long as the connection
is established in less than 2 seconds, the call can proceed. The 10
second call timeout still applies to the time taken for the whole call
(including the connection establishment). So, if establishing the
connection takes 1.5 seconds, and the call itself takes 9.5 seconds,
the call will time out because although it met the connection timeout,
it exceeded the 10 second total call timeout. On the other hand, if
establishing the connection takes 3 seconds, the call will fail after
only 2 seconds, since only 2 seconds are permitted for the connect.</P><P>If an object reference has multiple possible endpoints available, the
client will attempt to connect to them in turn, until one succeeds.
The connect timeout applies to each connection attempt. So with a
connect timeout of 2 seconds, the client will spend up to 2 seconds
attempting to connect to the first address and then, if that fails, up
to 2 seconds trying the second address, and so on. The 10 second
timeout still applies to the call as a whole, so if the total time
taken on timed-out connection attempts exceeds 10 seconds, the call
will time out.</P><P>This kind of configuration is useful where calls may take a long time
to complete (so call timeouts are long), but a fast indication of
connection failure is required.</P><!--TOC section Server side behaviour-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc95">6.4</A>&#XA0;&#XA0;Server side behaviour</H2><!--SEC END --><P>The server side has two primary modes of operation: thread per
connection and thread pooling. It is able to dynamically transition
between the two modes, and it supports a hybrid scheme that behaves
mostly like thread pooling, but has the same fast turn-around for
sequences of calls as thread per connection.</P><!--TOC subsection Thread per connection mode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc96">6.4.1</A>&#XA0;&#XA0;Thread per connection mode</H3><!--SEC END --><P>In thread per connection mode (the default, and the only option in
omniORB versions before 4.0), each connection has a single thread
dedicated to it. The thread blocks waiting for a request. When it
receives one, it unmarshals the arguments, makes the up-call to the
application code, marshals the reply, and goes back to watching the
connection. There is thus no thread switching along the call chain,
meaning the call is very efficient.</P><P>As explained above, a client can choose to multiplex multiple
concurrent calls on a single connection, so once the server has
received the request, and just before it makes the call into
application code, it marks the connection as &#X2018;selectable&#X2019;, meaning
that another thread should watch it to see if any other requests
arrive. If they do, extra threads are dispatched to handle the
concurrent calls. GIOP 1.2 actually allows the argument data for
multiple calls to be interleaved on a connection, so the unmarshalling
code has to handle that too. As soon as any multiplexing occurs on the
connection, the aim of removing thread switching cannot be met, and
there is inevitable inefficiency due to thread switching.</P><P>The <TT>maxServerThreadPerConnection</TT> parameter can be set to limit
the number of threads that can be allocated to a single connection
containing concurrent calls. Setting the parameter to 1 mimics the
behaviour of omniORB versions before 4.0, that did not support
calls multiplexed on one connection.</P><!--TOC subsection Thread pool mode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc97">6.4.2</A>&#XA0;&#XA0;Thread pool mode</H3><!--SEC END --><P>
<A NAME="sec:watchConn"></A></P><P>In thread pool mode, selected by setting the
<TT>threadPerConnectionPolicy</TT> parameter to zero, a single thread
watches all incoming connections. When a call arrives on one of them,
a thread is chosen from a pool of threads, and set to work
unmarshalling the arguments and performing the up-call. There is
therefore at least one thread switch for each call.</P><P>The thread pool is not pre-initialised. Instead, threads are started
on demand, and idle threads are stopped after a period of inactivity.
The maximum number of threads that can be started in the pool is set
with the <TT>maxServerThreadPoolSize</TT> parameter. The default
is 100.</P><P>A common pattern in CORBA applications is for a client to make several
calls to a single object in quick succession. To handle this situation
most efficiently, the default behaviour is to not return a thread to
the pool immediately after a call is finished. Instead, it is set to
watch the connection it has just served for a short while, mimicking
the behaviour in thread per connection mode. If a new call comes in
during the watching period, the call is dispatched without any thread
switching, just as in thread per connection mode. Of course, if the
server is supporting a very large number of connections (more than the
size of the thread pool), this policy can delay a call coming from
another connection. If the <TT>threadPoolWatchConnection</TT>
parameter is set to zero, connection watching is disabled and threads
return to the pool immediately after finishing a single request.</P><P>In the face of multiplexed calls on a single connection, multiple
threads from the pool can be dispatched for one connection, just as in
thread per connection mode. With <TT>threadPoolWatchConnection</TT> set
to the default value of 1, only the last thread servicing a connection
will watch it when it finishes a request. Setting the parameter to a
larger number allows the last <EM>n</EM> connections to watch the
connection.</P><!--TOC subsection Policy transition-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc98">6.4.3</A>&#XA0;&#XA0;Policy transition</H3><!--SEC END --><P>If the server is dealing with a relatively small number of
connections, it is most efficient to use thread per connection mode.
If the number of connections becomes too large, however, operating
system limits on the number of threads may cause a significant
slowdown, or even prevent the acceptance of new connections
altogether.</P><P>To give the most efficient response in all circumstances, omniORB
allows a server to start in thread per connection mode, and transition
to thread pooling if many connections arrive. This is controlled with
the <TT>threadPerConnectionUpperLimit</TT> and
<TT>threadPerConnectionLowerLimit</TT> parameters. The upper limit must
always be larger than the lower limit. The upper limit chooses the
number of connections at which time the ORB transitions to thread pool
mode; the lower limit selects the point at which the transition back
to thread per connection is made.</P><P>For example, setting the upper limit to 50 and the lower limit to 30
would mean that the first 49 connections would receive dedicated
threads. The 50th to arrive would trigger thread pooling. All future
connections to arrive would make use of threads from the pool. Note
that the existing dedicated threads continue to service their
connections until the connections are closed. If the number of
connections falls below 30, thread per connection is reactivated and
new connections receive their own dedicated threads (up to the limit
of 50 again). Once again, existing connections in thread pool mode
stay in that mode until they are closed.</P><!--TOC section Idle connection shutdown-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">6.5</A>&#XA0;&#XA0;Idle connection shutdown</H2><!--SEC END --><P>
<A NAME="sec:connShutdown"></A></P><P>It is wasteful to leave a connection open when it has been left unused
for a considerable time. Too many idle connections could block out new
connections when the system runs out of spare communication channels.
For example, most platforms have a limit on the number of file handles
a process can open. Many platforms have a very small default limit
like 64. The value can often be increased to a maximum of a thousand
or more by changing the &#X2018;ulimit&#X2019; in the shell.</P><P>Every so often, a thread scans all open connections to see which are
idle. The scanning period (in seconds) is set with the
<TT>scanGranularity</TT> parameter. The default is 5 seconds.</P><P>Outgoing connections (initiated by clients) and incoming connections
(initiated by servers) have separate idle timeouts. The timeouts are
set with the <TT>outConScanPeriod</TT> and <TT>inConScanPeriod</TT>
parameters respectively. The values are in seconds, and must be a
multiple of the scan granularity.</P><P>Beware that setting <TT>outConScanPeriod</TT> or <TT>inConScanPeriod</TT>
to be equal to (or less than) <TT>scanGranularity</TT> means that
connections are considered candidates for closure immediately after
they are opened. That can mean that the connections are closed before
any calls have been sent through them. If oneway calls are used, such
connection closure can result in silent loss of calls.</P><!--TOC subsection Interoperability Considerations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc100">6.5.1</A>&#XA0;&#XA0;Interoperability Considerations</H3><!--SEC END --><P>The IIOP specification allows both the client and the server to
shutdown a connection unilaterally. When one end is about to shutdown
a connection, it should send a <TT>CloseConnection</TT> message to the
other end. It should also make sure that the message will reach the
other end before it proceeds to shutdown the connection.</P><P>The client should distinguish between an orderly and an abnormal
connection shutdown. When a client receives a <TT>CloseConnection</TT>
message before the connection is closed, the condition is an orderly
shutdown. If the message is not received, the condition is an
abnormal shutdown. In an abnormal shutdown, the ORB should raise a
<TT>COMM_FAILURE</TT> exception whereas in an orderly shutdown, the ORB
should <EM>not</EM> raise an exception and should try to re-establish a
new connection transparently.</P><P>omniORB implements these semantics completely. However, it is known
that some ORBs are not (yet) able to distinguish between an orderly
and an abnormal shutdown. Usually this is manifested as the client in
these ORBs seeing a <TT>COMM_FAILURE</TT> occasionally when connected
to an omniORB server. The work-around is either to catch the exception
in the application code and retry, or to turn off the idle connection
shutdown inside the omniORB server.</P><!--TOC section Transports and endpoints-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc101">6.6</A>&#XA0;&#XA0;Transports and endpoints</H2><!--SEC END --><P>
<A NAME="sec:endpoints"></A></P><P>omniORB can support multiple network transports. All platforms
(usually) have a TCP transport available. Unix platforms support a
Unix domain socket transport. Platforms with the OpenSSL library
available can support an SSL transport.</P><P>Servers must be configured in two ways with regard to transports: the
transports and interfaces on which they listen, and the details that
are published in IORs for clients to see. Usually the published
details will be the same as the listening details, but there are times
when it is useful to publish different information.</P><P>Details are selected with the <TT>endPoint</TT> family of parameters.
The simplest is plain <TT>endPoint</TT>, which chooses a transport and
interface details, and publishes the information in IORs. Endpoint
parameters are in the form of URIs, with a scheme name of
&#X2018;<TT>giop:</TT>&#X2019;, followed by the transport name. Different transports
have different parameters following the transport.</P><P>TCP endpoints have the format:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp:</TT><I>&lt;host&gt;</I><TT>:</TT><I>&lt;port&gt;</I>
</BLOCKQUOTE><P>The host must be a valid host name or IP address for the
server machine. It determines the network interface on which the
server listens. The port selects the TCP port to listen on, which must
be unoccupied. Either the host or port, or both can be left empty. If
the host is empty, the ORB publishes the IP address of the first
non-loopback network interface it can find (or the loopback if that is
the only interface), but listens on <EM>all</EM> network interfaces. If
the port is empty, the operating system chooses an <I>ephemeral</I>
port.</P><P>Multiple TCP endpoints can be selected, either to specify multiple
network interfaces on which to listen, or (less usefully) to select
multiple TCP ports on which to listen.</P><P>If no <TT>endPoint</TT> parameters are set, the ORB assumes a single
parameter of <TT>giop:tcp::</TT>, meaning IORs contain the address of
the first non-loopback network interface, the ORB listens on all
interfaces, and the OS chooses a port number.</P><P>SSL endpoints have the same format as TCP ones, except &#X2018;<TT>tcp</TT>&#X2019;
is replaced with &#X2018;<TT>ssl</TT>&#X2019;. Unix domain socket endpoints have the
format:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:unix:</TT><I>&lt;filename&gt;</I>
</BLOCKQUOTE><P>where the filename is the name of the socket within the
filesystem. If the filename is left blank, the ORB chooses a name
based on the process id and a timestamp.</P><P>To listen on an endpoint without publishing it in IORs, specify it
with the <TT>endPointNoPublish</TT> configuration parameter. See below
for more details about endpoint publishing.</P><!--TOC subsection Port ranges-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">6.6.1</A>&#XA0;&#XA0;Port ranges</H3><!--SEC END --><P>Sometimes it is useful to restrict a server to listen on one of a
range of ports, rather than pinning it to one particular port or
allowing the OS to choose an ephemeral port. omniORB 4.2 introduces
the ability to specify a range of ports using a hyphen. e.g. to
listen on a port between 5000 and 5010 inclusive:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp::5000-5010</TT>
</BLOCKQUOTE><P>omniORB randomly chooses a port in the range. If it finds that the
chosen port is already occupied, it keeps trying different ports until
it finds a free one. If all the ports in the range are occupied, it
throws <TT>CORBA::INITIALIZE</TT>.</P><!--TOC subsection IPv6-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc103">6.6.2</A>&#XA0;&#XA0;IPv6</H3><!--SEC END --><P>On platforms where it is available, omniORB supports IPv6. On most
Unix platforms, IPv6 sockets accept both IPv6 and IPv4 connections, so
omniORB&#X2019;s default <TT>giop:tcp::</TT> endpoint accepts both IPv4 and
IPv6 connections. On Windows versions before Windows Vista, each
socket type only accepts incoming connections of the same type, so an
IPv6 socket cannot be used with IPv4 clients. For this reason, the
default <TT>giop:tcp::</TT> endpoint only listens for IPv4 connections.
Since endpoints with a specific host name or address only listen on a
single network interface, they are inherently limited to just one
protocol family.</P><P>To explicitly ask for just IPv4 or just IPv6, an endpoint with the
wildcard address for the protocol family should be used. For IPv4, the
wildcard address is &#X2018;<TT>0.0.0.0</TT>&#X2019;, and for IPv6 it is &#X2018;<TT>::</TT>&#X2019;.
So, to listen for IPv4 connections on all IPv4 network interfaces, use
an endpoint of:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp:0.0.0.0:</TT>
</BLOCKQUOTE><P>All IPv6 addresses contain colons, so the address portion in
URIs must be contained within <TT>[]</TT> characters. Therefore, to
listen just for IPv6 connections on all IPv6 interfaces, use the
somewhat cryptic:</P><BLOCKQUOTE CLASS="quote">
<TT>giop:tcp:[::]:</TT>
</BLOCKQUOTE><P>To listen for both IPv4 and IPv6 connections on Windows
versions prior to Vista, both endpoints must be explicitly provided.</P><!--TOC subsubsection Link local addresses-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc104">6.6.2.1</A>&#XA0;&#XA0;Link local addresses</H4><!--SEC END --><P>In IPv6, all network interfaces are assigned a <I>link local</I>
address, starting with the digits <TT>fe80</TT>. The link local address
is only valid on the same &#X2018;link&#X2019; as the interface, meaning directly
connected to the interface, or possibly on the same subnet, depending
on how the network is switched. To connect to a server&#X2019;s link local
address, a client has to know which of its network interfaces is on
the same link as the server. Since there is no way for omniORB to know
which local interface a remote link local address may be connected to,
and in extreme circumstances may even end up contacting the wrong
server if it picks the wrong interface, link local addresses are not
considered valid. Servers do not publish link local addresses in their
IORs.</P><!--TOC subsection Endpoint publishing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc105">6.6.3</A>&#XA0;&#XA0;Endpoint publishing</H3><!--SEC END --><P>For clients to be able to connect to a server, the server publishes
endpoint information in its IORs (Interoperable Object References).
Normally, omniORB publishes the first available address for each of
the endpoints it is listening on.</P><P>The endpoint information to publish is determined by the
<TT>endPointPublish</TT> configuration parameter. It contains a
comma-separated list of publish rules. The rules are applied in turn
to each of the configured endpoints; if a rule matches an endpoint, it
causes one or more endpoints to be published.</P><P>The following core rules are supported:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>addr</TT></TD><TD VALIGN=top ALIGN=left>the first natural address of the endpoint</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>ipv4</TT></TD><TD VALIGN=top ALIGN=left>the first IPv4 address of a TCP or SSL endpoint</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>ipv6</TT></TD><TD VALIGN=top ALIGN=left>the first IPv6 address of a TCP or SSL endpoint</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>name</TT></TD><TD VALIGN=top ALIGN=left>the first address that can be resolved to a name</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>hostname</TT></TD><TD VALIGN=top ALIGN=left>the result of the gethostname() system call</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>fqdn</TT></TD><TD VALIGN=top ALIGN=left>the fully-qualified domain name</TD></TR>
</TABLE><P>The core rules can be combined using the vertical bar operator to
try several rules in turn until one succeeds. e.g:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>name|ipv6|ipv4</TT></TD><TD VALIGN=top ALIGN=left>the name of the endpoint if it has one;
	failing that, its first IPv6 address;
	failing that, its first IPv4 address.</TD></TR>
</TABLE><P>Multiple rules can be combined using the comma operator to
publish more than one endpoint. e.g.</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>name,addr</TT></TD><TD VALIGN=top ALIGN=left>the name of the endpoint (if it has one),
followed by its first address.</TD></TR>
</TABLE><P>For endpoints with multiple addresses (e.g. TCP endpoints on
multi-homed machines), the <TT>all()</TT> manipulator causes all
addresses to be published. e.g.:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>all(addr)</TT></TD><TD VALIGN=top ALIGN=left>all addresses are published</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name)</TT></TD><TD VALIGN=top ALIGN=left>all addresses that resolve to names are published</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name|addr)</TT></TD><TD VALIGN=top ALIGN=left>all addresses are published by name if they have
one, address otherwise.</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name,addr)</TT></TD><TD VALIGN=top ALIGN=left>all addresses are published by name (if they
have one), and by address.</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>all(name), all(addr)</TT></TD><TD VALIGN=top ALIGN=left>first the names of all addresses are published,
followed by all the addresses.</TD></TR>
</TABLE><P>A specific endpoint can be published by giving its endpoint URI,
even if the server is not listening on that endpoint. e.g.:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>giop:tcp:not.my.host:12345</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>giop:unix:/not/my/socket-file</TT></TD></TR>
</TABLE><P>If the host or port number for a TCP or SSL URI are missed out,
they are filled in with the details from each listening TCP/SSL
endpoint. This can be used to publish a different name for a
TCP/SSL endpoint that is using an ephemeral port, for example.</P><P>omniORB 4.0 supported two options related to endpoint publishing that
are superseded by the <TT>endPointPublish</TT> parameter, and so are now
deprecated. Setting <TT>endPointPublishAllIFs</TT> to 1 is equivalent to
setting <TT>endPointPublish</TT> to &#X2018;<TT>all(addr)</TT>&#X2019;. The
<TT>endPointNoListen</TT> parameter is equivalent to adding endpoint
URIs to the <TT>endPointPublish</TT> parameter.</P><!--TOC section Connection selection and acceptance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc106">6.7</A>&#XA0;&#XA0;Connection selection and acceptance</H2><!--SEC END --><P>In the face of IORs containing details about multiple different
endpoints, clients have to know how to choose the one to use to
connect a server. Similarly, servers may wish to restrict which
clients can connect to particular transports. This is achieved with
<I>transport rules</I>.</P><!--TOC subsection Client transport rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc107">6.7.1</A>&#XA0;&#XA0;Client transport rules</H3><!--SEC END --><P>
<A NAME="sec:clientRule"></A></P><P>The <TT>clientTransportRule</TT> parameter is used to filter and
prioritise the order in which transports specified in an IOR are
tried. Each rule has the form:</P><BLOCKQUOTE CLASS="quote">
<I>&lt;address mask&gt; [action]+</I>
</BLOCKQUOTE><P>The address mask can be one of</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>1.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>localhost</TT></TD><TD VALIGN=top ALIGN=left>The address of this machine</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
2.</TD><TD VALIGN=top ALIGN=left NOWRAP><I>w.x.y.z</I><TT>/</TT><I>m1.m2.m3.m4</I></TD><TD VALIGN=top ALIGN=left>An IPv4 address
with bits selected by the mask, e.g.
 <TT>172.16.0.0/255.240.0.0</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
3.</TD><TD VALIGN=top ALIGN=left NOWRAP><I>w.x.y.z</I><TT>/</TT><I>prefixlen</I></TD><TD VALIGN=top ALIGN=left>An IPv4 address with
<I>prefixlen</I> significant bits, e.g.
 <TT>172.16.2.0/24</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
4.</TD><TD VALIGN=top ALIGN=left NOWRAP><I>a:b:c:d:e:f:g:h</I><TT>/</TT><I>prefixlen</I></TD><TD VALIGN=top ALIGN=left>An IPv6
address with <I>prefixlen</I> significant bits, e.g.
 <TT>3ffe:505:2:1::/64</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
5.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>*</TT></TD><TD VALIGN=top ALIGN=left>Wildcard that matches any address</TD></TR>
</TABLE><P>The action is one or more of the following:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>1.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>none</TT></TD><TD VALIGN=top ALIGN=left>Do not use this address</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>2.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>tcp</TT></TD><TD VALIGN=top ALIGN=left>Use a TCP transport</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>3.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>ssl</TT></TD><TD VALIGN=top ALIGN=left>Use an SSL transport</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>4.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>unix</TT></TD><TD VALIGN=top ALIGN=left>Use a Unix socket transport</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>5.</TD><TD VALIGN=top ALIGN=left NOWRAP><TT>bidir</TT></TD><TD VALIGN=top ALIGN=left>Connections to this address can be used
bidirectionally (see section&#XA0;<A HREF="#sec:bidir">6.8</A>)</TD></TR>
</TABLE><P>The transport-selecting actions form a prioritised list, so
an action of &#X2018;<TT>unix,ssl,tcp</TT>&#X2019; means to use a Unix transport if
there is one, failing that a SSL transport, failing <EM>that</EM> a TCP
transport. In the absence of any explicit rules, the client uses the
implicit rule of &#X2018;<TT>* unix,ssl,tcp</TT>&#X2019;.</P><P>If more than one rule is specified, they are prioritised in the order
they are specified. For example, the configuration file might contain:</P><PRE CLASS="verbatim">  clientTransportRule = 192.168.1.0/255.255.255.0  unix,tcp
  clientTransportRule = 172.16.0.0/255.240.0.0     unix,tcp
                      =       *                    none
</PRE><P>This would be useful if there is a fast network
(192.168.1.0) which should be used in preference to another network
(172.16.0.0), and connections to other networks are not permitted at
all.</P><P>In general, the result of filtering the endpoint specifications in an
IOR with the client transport rule will be a prioritised list of
transports and networks. (If the transport rules do not prioritise one
endpoint over another, the order the endpoints are listed in the IOR
is used.) When trying to contact an object, the ORB tries its
possible endpoints in turn, until it finds one with which it can
contact the object. Only after it has unsuccessfully tried all
permissible endpoints will it raise a <TT>TRANSIENT</TT> exception to
indicate that the connect failed.</P><!--TOC subsection Server transport rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">6.7.2</A>&#XA0;&#XA0;Server transport rules</H3><!--SEC END --><P>
<A NAME="sec:serverRule"></A></P><P>Server transport rules have the same format as client transport
rules. Rather than being used to select which of a set of ways to
contact a machine, they are used to determine whether or not to accept
connections from particular clients. In this example, we only allow
connections from our intranet:</P><PRE CLASS="verbatim">  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          none
</PRE><P>And in this one, we accept only SSL connections if the
client is not on the intranet:</P><PRE CLASS="verbatim">  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          ssl,bidir
</PRE><P>In the absence of any explicit rules, the server uses the
implicit rule of &#X2018;<TT>* unix,ssl,tcp</TT>&#X2019;, meaning any kind of
connection is accepted from any client.</P><!--TOC section Bidirectional GIOP-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc109">6.8</A>&#XA0;&#XA0;Bidirectional GIOP</H2><!--SEC END --><P>
<A NAME="sec:bidir"></A></P><P>omniORB supports bidirectional GIOP, which allows callbacks to be made
using a connection opened by the original client, rather than the
normal model where the server opens a new connection for the callback.
This is important for negotiating firewalls, since they tend not to
allow connections back on arbitrary ports.</P><P>There are several steps required for bidirectional GIOP to be enabled
for a callback. Both the client and server must be configured
correctly. On the client side, these conditions must be met:</P><UL CLASS="itemize"><LI CLASS="li-itemize">The <TT>offerBiDirectionalGIOP</TT> parameter must be set to <TT>true</TT>. 
</LI><LI CLASS="li-itemize">The client transport rule for the target server must contain the
<TT>bidir</TT> action.
</LI><LI CLASS="li-itemize">The POA containing the callback object (or objects) must have
been created with a <TT>BidirectionalPolicy</TT> value of
<TT>BOTH</TT>.</LI></UL><P>On the server side, these conditions must be met:</P><UL CLASS="itemize"><LI CLASS="li-itemize">The <TT>acceptBiDirectionalGIOP</TT> parameter must be set to <TT>true</TT>. 
</LI><LI CLASS="li-itemize">The server transport rule for the requesting client must contain
the <TT>bidir</TT> action.
</LI><LI CLASS="li-itemize">The POA hosting the object contacted by the client must have
been created with a <TT>BidirectionalPolicy</TT> value of
<TT>BOTH</TT>.</LI></UL><!--TOC section TLS / SSL transport-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc110">6.9</A>&#XA0;&#XA0;TLS / SSL transport</H2><!--SEC END --><P>omniORB supports a TLS / SSL transport, using OpenSSL. It is only
built if OpenSSL is available. On platforms using Autoconf, it is
autodetected in many locations, or its location can be given with the
<TT>--with-openssl=</TT> argument to <TT>configure</TT>. On other
platforms, the <TT>OPEN_SSL_ROOT</TT> make variable must be set in the
platform file.</P><P>To use the SSL transport, you must link your application with the
<TT>omnisslTP</TT> library, and correctly set up certificates. See the
<TT>src/examples/ssl_echo</TT> directory for an example. That directory
contains a <TT>README</TT> file with more details.</P><!--TOC subsection Self-signed certificate authority-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc111">6.9.1</A>&#XA0;&#XA0;Self-signed certificate authority</H3><!--SEC END --><P>By default, omniORB configures OpenSSL to require both clients and
servers to have certificates that are signed by a Certificate
Authority (CA). It is possible to use a public CA to obtain keys that
can be independently verified, but for many purposes, it is sufficient
to use a private CA to sign all the keys in use in an application. The
following is a brief description of how to become your own certificate
authority and issue and sign certificates, using the OpenSSL command
line tools.</P><P>Before starting, find the default <TT>openssl.cnf</TT> file that was
installed with OpenSSL, copy it to a suitable location, and edit it as
you feel appropriate. Now, build a certificate directory structure,
authority key and certificate:</P><PRE CLASS="verbatim">  mkdir demoCA demoCA/private demoCA/newcerts

  openssl req -config openssl.cnf -x509 -newkey rsa:2048 \
     -keyout demoCA/private/cakey.pem -out demoCA/cacert.pem -days 3650

  echo 01 &gt;demoCA/serial
  touch demoCA/index.txt
</PRE><P>Next, issue a key request and sign it:</P><PRE CLASS="verbatim">  openssl req -config openssl.cnf -new -keyout server_key.pem \
     -out server_req.pem -days 3650

  openssl ca -config openssl.cnf -policy policy_anything \
     -out server_cert.pem -in server_req.pem 
</PRE><P>Amongst other things, you now have a server key file in
<TT>server_key.pem</TT> and a certificate in <TT>server_cert.pem</TT>. To
make a single file containing both the key and the certificate,
suitable for use in omniORB, concatenate the key and certificate files
together. You can skip the human-readable(ish) text in the
certificate file before the <CODE>-----BEGIN CERTIFICATE-----</CODE> marker.</P><P>If need be, create more certificates for servers and clients in the
same way.</P><!--TOC section ZIOP-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc112">6.10</A>&#XA0;&#XA0;ZIOP</H2><!--SEC END --><P>omniORB has support for ZIOP, which compresses transmitted
messages. To use it, link with the <TT>omniZIOP4</TT> library.</P><P>On Unix platforms, ZIOP support is automatically enabled if the
configure script detects zlib. To enable it on Windows, set the
<TT>EnableZIOP</TT> make variable in the platform configuration file.</P><P>omniORB has an almost complete implementation of the ZIOP
specification, with the following extensions and differences:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
To avoid a dependency on <TT>CORBA::Any</TT>, compression policies
can be obtained with functions in the <TT>omniZIOP</TT> namespace,
rather than with the standard <TT>orb-&gt;create_policy()</TT>. See
<TT>include/omniORB4/omniZIOP.h</TT> for details. To use <TT>Any</TT>
with the standard <TT>orb-&gt;create_policy()</TT>, link with the
<TT>omniZIOPDynamic4</TT> library in addition to <TT>omniZIOP4</TT>.</LI><LI CLASS="li-enumerate">Client-side policies are global, set with
<TT>omniZIOP::setGlobalPolicies()</TT>.
<TT>CORBA::Object::_set_policy_overrides()</TT> is not supported.</LI><LI CLASS="li-enumerate">POAs can be given ZIOP policies as shown in the
<TT>src/examples/ziop/ziop_impl.cc</TT>, but they can also use the
global policies set with <TT>omniZIOP::setGlobalPolicies()</TT>. This
is useful to apply ZIOP policies to the RootPOA or omniINSPOA.
</LI></OL><P>In addition to the standard policies, whether or not to
enable ZIOP is determined by client and server transport rules. For a
client to use ZIOP, the matching client transport rule must include
&#X2018;<TT>ziop</TT>&#X2019;; similarly, for a server to use ZIOP, the matching
server transport rule must include &#X2018;<TT>ziop</TT>&#X2019;. e.g. to use the
examples:</P><PRE CLASS="verbatim">  ziop_impl -ORBserverTransportRule "* unix,ssl,tcp,ziop"

  ziop_clt -ORBclientTransportRule "* unix,ssl,tcp,ziop" IOR:...
</PRE><P>This allows you to enable ZIOP for WAN links, but disable it
for LAN communication, for example.</P><!--TOC subsection Forcing ZIOP Policies-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">6.10.1</A>&#XA0;&#XA0;Forcing ZIOP Policies</H3><!--SEC END --><P>The fact that a server supports ZIOP is encoded in its IORs. This
means that if a client uses a <TT>corbaloc</TT> URI to reference an
object, the object reference does not contain ZIOP details, and thus
the communication cannot use ZIOP. If a client is absolutely certain
that a server supports ZIOP, it can extend an object reference with
ZIOP details using <TT>omniZIOP::setServerPolicies()</TT>. Using the new
object reference, the client will be able to make ZIOP calls.</P><DIV CLASS="lstlisting"><B>namespace</B> omniZIOP {
  CORBA::Object_ptr
  setServerPolicies(CORBA::Object_ptr obj, <B>const</B> CORBA::PolicyList&amp; policies);
};</DIV><P>Creating a ZIOP-enabling object reference in this way is dangerous!
If the server does not actually support ZIOP, it will receive
compressed messages that it cannot handle. A well-behaved server will
throw a <TT>CORBA::MARSHAL</TT> exception in response, or perhaps just
drop the invalid connection.</P><!--TOC section Connection Management Extension-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc114">6.11</A>&#XA0;&#XA0;Connection Management Extension</H2><!--SEC END --><P>The <TT>omniConnectionMgmt</TT> library provides an omniORB-specific
extension for application-level connection management. Its purpose is
to allow clients and servers to negotiate private GIOP connections,
and to control how the connections are used in multi-threaded
situations.</P><P>The <TT>omniConnectionMgmt</TT> library has two functions, defined in
<TT>include/omniORB4/omniConnectionMgmt.h</TT>:</P><DIV CLASS="lstlisting"><B>namespace</B> omniConnectionMgmt {

  <B>void</B> init();

  CORBA::Object_ptr
  makeRestrictedReference(CORBA::Object_ptr obj,
                          CORBA::ULong      connection_id,
                          CORBA::ULong      max_connections,
                          CORBA::ULong      max_threads,
                          CORBA::Boolean    data_batch,
                          CORBA::Boolean    permit_interleaved,
                          CORBA::Boolean    server_hold_open);
};</DIV><P>The <TT>init()</TT> function must be called before
<TT>CORBA::ORB_init()</TT> in every process that is to take part in the
connection management.</P><P>The <TT>makeRestrictedReference()</TT> function is the single entry-point to
the connection management functionality. It builds an annotated object
reference that contains information for the connection management
system. It returns a new reference, leaving the original object
reference unchanged.</P><!--TOC subsection Client-side parameters-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc115">6.11.1</A>&#XA0;&#XA0;Client-side parameters</H3><!--SEC END --><P>These parameters affect the client side of a connection:</P><P><TT>connection_id</TT></P><P>This number identifies the private connection set. All object
references with the same <TT>connection_id</TT> will share the same set
of GIOP connections. Object references with different connection ids
are guaranteed to use different connections from each other, and from
object references that have not been annotated with
<TT>makeRestrictedReference()</TT>.</P><P><TT>max_connections</TT></P><P>This parameter overrides the omniORB <TT>maxGIOPConnectionPerServer</TT>
configuration parameter for the given <TT>connection_id</TT>. It
determines the maximum number of separate GIOP connections that will
be opened to the object&#X2019;s server to service concurrent calls. It is
common to set this value to 1, indicating that only one connection
will be used for the given <TT>connection_id</TT>. Note that this
parameter can only be used to reduce the default
<TT>maxGIOPConnectionPerServer</TT> value, not increase it.</P><P><TT>data_batch</TT></P><P>omniORB usually configures its TCP connections to disable Nagle&#X2019;s
algorithm, which batches small messages together into single IP
packages, since that is best for the usual CORBA usage pattern of
two-way requests. Setting this parameter to true overrides that, and
enables Nagle&#X2019;s algorithm on TCP connections or equivalent
functionality on other transports. This can increase throughput if a
client is sending a large number of small oneway calls.</P><P><TT>permit_interleaved</TT></P><P>This parameter overrides the <TT>oneCallPerConnection</TT> configuration
parameter that determines whether multi-threaded clients can
interleave calls on a single connection, issuing a new request message
while a previous request is still waiting for a reply. If
<TT>permit_interleaved</TT> is true, clients can interleave messages;
if it is false, they cannot.</P><!--TOC subsection Server-side parameters-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc116">6.11.2</A>&#XA0;&#XA0;Server-side parameters</H3><!--SEC END --><P>These parameters affect the client side of a connection:</P><P><TT>max_threads</TT></P><P>This parameter overrides the global
<TT>maxServerThreadPerConnection</TT> configuration parameter that
determines the maximum number of concurrent threads the server will
use to service requests coming from a connection. Note that this
parameter is only relevant if either the client permits interleaved
calls, or if oneway operations are used, since those are the only
circumstances under which the server can receive a new request on a
connection while already handling a request. As with the
<TT>max_connections</TT> client-side parameter, this parameter can only
reduce the default number of threads, not increase it.</P><P><TT>server_hold_open</TT></P><P>Normally, both clients and servers can decide to close a GIOP
connection at any time. When using normal two-way calls, this is no
problem since if a server closes a connection, the client is
guaranteed to notice it when it waits for a reply, and can retry the
call if necessary. With oneway calls, however, if a server closes a
connection just as the client is sending a request, the client will
not know whether the oneway call was received or not, and the call
will potentially be lost. By setting the <TT>server_hold_open</TT>
parameter to true, the server will not close the connection, relying
on the client to do so. In that case, oneway calls will not be lost
unless there is a network problem that breaks the GIOP connection.</P><!--TOC subsection Usage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">6.11.3</A>&#XA0;&#XA0;Usage</H3><!--SEC END --><P>The omniConnectionMgmt extension is very easy to use&#X2014;simply call the
<TT>init()</TT> method in all processes involved, then restrict references
as required. The <TT>makeRestrictedReference()</TT> function adds profile
information to the object reference&#X2019;s IOR, meaning that the parameters
become part of the object reference and are transmitted along with
it. In other words, a server can create a restricted reference and
send it to a client, and the client will automatically make use of the
restricted parameters when it invokes operations on the object
reference. Alternatively, a client can restrict a normal reference it
receives, in order to change its own behaviour.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note12" HREF="#text12">1</A></DT><DD CLASS="dd-thefootnotes">GIOP 1.2 supports
&#X2018;bidirectional GIOP&#X2019;, which permits the r&#XF4;les to be reversed.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note13" HREF="#text13">2</A></DT><DD CLASS="dd-thefootnotes">Or
<TT>CORBA::TRANSIENT</TT> if the backwards-compatibility
<TT>throwTransientOnTimeout</TT> parameter is set to <TT>1</TT>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Interoperable Naming Service-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc118">Chapter&#XA0;7</A>&#XA0;&#XA0;Interoperable Naming Service</H1><!--SEC END --><P>
<A NAME="chap:ins"></A></P><P>omniORB supports the Interoperable Naming Service (INS). The following
is a summary of its facilities.</P><!--TOC section Object URIs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc119">7.1</A>&#XA0;&#XA0;Object URIs</H2><!--SEC END --><P>As well as accepting IOR-format strings, <TT>ORB::string_to_object()</TT>
also supports two Uniform Resource Identifier (URI)&#XA0;[<A HREF="#rfc2396">BLFIM98</A>]
formats, which can be used to specify objects in a convenient
human-readable form. IOR-format strings are now also considered URIs.</P><!--TOC subsection corbaloc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc120">7.1.1</A>&#XA0;&#XA0;corbaloc</H3><!--SEC END --><P><TT>corbaloc</TT> URIs allow you to specify object references which
can be contacted by IIOP, or found through
<TT>ORB::resolve_initial_references()</TT>. To specify an IIOP object
reference, you use a URI of the form:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:iiop:</TT>&lt;<I>host</I>&gt;<TT>:</TT>&lt;<I>port</I>&gt;<TT>/</TT>&lt;<I>object key</I>&gt;
</BLOCKQUOTE><P>for example:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:iiop:myhost.example.com:1234/MyObjectKey</TT>
</BLOCKQUOTE><P>which specifies an object with key &#X2018;MyObjectKey&#X2019; within a
process running on myhost.example.com listening on port 1234. Object
keys containing non-ASCII characters can use the standard URI %
escapes:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc:iiop:myhost.example.com:1234/My</TT><TT>%</TT><TT>efObjectKey</TT>
</BLOCKQUOTE><P>denotes an object key with the value 239 (hex ef) in the
third octet.</P><P>The protocol name &#X2018;<TT>iiop</TT>&#X2019; can be abbreviated to the empty
string, so the original URI can be written:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::myhost.example.com:1234/MyObjectKey</TT>
</BLOCKQUOTE><P>The IANA has assigned port number 2809<SUP><A NAME="text14" HREF="#note14">1</A></SUP> for use by <TT>corbaloc</TT>, so if
the server is listening on that port, you can leave the port number
out. The following two URIs refer to the same object:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::myhost.example.com:2809/MyObjectKey</TT><BR>
<TT>corbaloc::myhost.example.com/MyObjectKey</TT>
</BLOCKQUOTE><P>You can specify an object which is available at more than
one location by separating the locations with commas:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::myhost.example.com,:localhost:1234/MyObjectKey</TT>
</BLOCKQUOTE><P>Note that you must restate the protocol for each address,
hence the &#X2018;<TT>:</TT>&#X2019; before &#X2018;<TT>localhost</TT>&#X2019;. It could
equally have been written &#X2018;<TT>iiop:localhost</TT>&#X2019;.</P><P>You can also specify an IIOP version number:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaloc::1.2@myhost.example.com/MyObjectKey</TT>
</BLOCKQUOTE><P>Specifying IIOP versions above 1.0 is slightly risky since
higher versions make use of various information stored in IORs that is
not present in a corbaloc URI. It is generally best to contact initial
corbaloc objects with IIOP 1.0, and rely on higher versions for all
other object references.</P><!--TOC subsection Other transports-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc121">7.1.2</A>&#XA0;&#XA0;Other transports</H3><!--SEC END --><P>The only transport specified in the CORBA standard is <TT>iiop</TT>,
but omniORB also supports the following extensions:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>ssliop</TT></B></DT><DD CLASS="dd-description"><BR>
Equivalent semantics to <TT>iiop</TT>, but the server is contacted
using SSL / TLS. As with <TT>iiop</TT>, the address details are of
the form <TT><I>host</I></TT><TT>:</TT><TT><I>port</I></TT>.</DD><DT CLASS="dt-description"><B><TT>omniunix</TT></B></DT><DD CLASS="dd-description"><BR>
The omniORB Unix domain socket transport. The address details are of
the form <TT><I>filename</I></TT>.</DD></DL><!--TOC subsection Resolve initial references-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc122">7.1.3</A>&#XA0;&#XA0;Resolve initial references</H3><!--SEC END --><P>A <TT>corbaloc:</TT> can also specify a call to
<TT>resolve_initial_references()</TT>. This</P><DIV CLASS="lstlisting">orb-&gt;string_to_object("corbaloc:rir:/NameService");</DIV><P>is identical in behaviour to</P><DIV CLASS="lstlisting">orb-&gt;resolve_initial_references("NameService");</DIV><!--TOC subsection corbaname-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc123">7.1.4</A>&#XA0;&#XA0;corbaname</H3><!--SEC END --><P>
<A NAME="sec:corbaname"></A></P><P><TT>corbaname</TT> URIs cause <TT>string_to_object()</TT> to look-up a
name in a CORBA Naming service. They are an extension of the
<TT>corbaloc</TT> syntax:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname:</TT>&lt;<I>corbaloc location</I>&gt;<TT>/</TT>&lt;<I>object key</I>&gt;<TT>#</TT>&lt;<I>stringified name</I>&gt;
</BLOCKQUOTE><P>for example:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname::myhost/NameService#project/example/echo.obj</TT><BR>
<TT>corbaname:rir:/NameService#project/example/echo.obj</TT>
</BLOCKQUOTE><P>The object found with the <TT>corbaloc</TT>-style portion
must be of type <TT>CosNaming::NamingContext</TT>, or something
derived from it. If the object key (or <TT>rir</TT> name) is
&#X2018;<TT>NameService</TT>&#X2019;, it can be left out:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname::myhost#project/example/echo.obj</TT><BR>
<TT>corbaname:rir:#project/example/echo.obj</TT>
</BLOCKQUOTE><P>The stringified name portion can also be left out, in which
case the URI denotes the <TT>CosNaming::NamingContext</TT> which would
have been used for a look-up:</P><BLOCKQUOTE CLASS="quote">
<TT>corbaname::myhost.example.com</TT><BR>
<TT>corbaname:rir:</TT>
</BLOCKQUOTE><P>The first of these examples is the easiest way of specifying
the location of a naming service.</P><!--TOC section Configuring resolve_initial_references-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc124">7.2</A>&#XA0;&#XA0;Configuring resolve_initial_references</H2><!--SEC END --><P>
<A NAME="sec:insargs"></A></P><P>The INS specifies two standard command line arguments which provide a
portable way of configuring <TT>ORB::resolve_initial_references()</TT>:</P><!--TOC subsection ORBInitRef-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc125">7.2.1</A>&#XA0;&#XA0;ORBInitRef</H3><!--SEC END --><P><TT>-ORBInitRef</TT> takes an argument of the form
&lt;<I>ObjectId</I>&gt;<TT>=</TT>&lt;<I>ObjectURI</I>&gt;. So, for example,
with command line arguments of:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBInitRef NameService=corbaname::myhost.example.com</TT>
</BLOCKQUOTE><P><TT>resolve_initial_references("NameService")</TT> will
return a reference to the object with key &#X2018;NameService&#X2019; available on
myhost.example.com, port 2809. Since IOR-format strings are considered
URIs, you can also say things like:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBInitRef NameService=IOR:00ff...</TT>
</BLOCKQUOTE><!--TOC subsection ORBDefaultInitRef-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">7.2.2</A>&#XA0;&#XA0;ORBDefaultInitRef</H3><!--SEC END --><P><TT>-ORBDefaultInitRef</TT> provides a prefix string which is used to
resolve otherwise unknown names. When
<TT>resolve_initial_references()</TT> is unable to resolve a name which
has been specifically configured (with <TT>-ORBInitRef</TT>), it
constructs a string consisting of the default prefix, a &#X2018;<TT>/</TT>&#X2019;
character, and the name requested. The string is then fed to
<TT>string_to_object()</TT>. So, for example, with a command line of:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBDefaultInitRef corbaloc::myhost.example.com</TT>
</BLOCKQUOTE><P>a call to <TT>resolve_initial_references("MyService")</TT>
will return the object reference denoted by
&#X2018;<TT>corbaloc::myhost.example.com/MyService</TT>&#X2019;.</P><P>Similarly, a <TT>corbaname</TT> prefix can be used to cause
look-ups in the naming service. Note, however, that since a
&#X2018;<TT>/</TT>&#X2019; character is always added to the prefix, it is
impossible to specify a look-up in the root context of the naming
service&#X2014;you have to use a sub-context, like:</P><BLOCKQUOTE CLASS="quote">
<TT>-ORBDefaultInitRef corbaname::myhost.example.com#services</TT>
</BLOCKQUOTE><!--TOC section omniNames-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc127">7.3</A>&#XA0;&#XA0;omniNames</H2><!--SEC END --><!--TOC subsection NamingContextExt-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc128">7.3.1</A>&#XA0;&#XA0;NamingContextExt</H3><!--SEC END --><P>omniNames supports the extended <TT>CosNaming::NamingContextExt</TT>
interface:</P><DIV CLASS="lstlisting"><B>module</B> CosNaming {
  <B>interface</B> NamingContextExt : NamingContext {
    <B>typedef</B> <B>string</B> StringName;
    <B>typedef</B> <B>string</B> Address;
    <B>typedef</B> <B>string</B> URLString;

    StringName  to_string(<B>in</B> Name n)        <B>raises</B>(InvalidName);
    Name        to_name  (<B>in</B> StringName sn) <B>raises</B>(InvalidName);

    <B>exception</B> InvalidAddress {};

    URLString   to_url(<B>in</B> Address addr, <B>in</B> StringName sn)
      <B>raises</B>(InvalidAddress, InvalidName);

    <B>Object</B>      resolve_str(<B>in</B> StringName n)
      <B>raises</B>(NotFound, CannotProceed, InvalidName, AlreadyBound);
  };
};</DIV><P><TT>to_string()</TT> and <TT>to_name()</TT> convert from <TT>CosNaming::Name</TT>
sequences to flattened strings and vice-versa. Note that calling
these operations involves remote calls to the naming service, so they
are not particularly efficient. You can use the omniORB specific local
<TT>omniURI::nameToString()</TT> and <TT>omniURI::stringToName()</TT>
functions instead.</P><P>A <TT>CosNaming::Name</TT> is stringified by separating name components
with &#X2018;<TT>/</TT>&#X2019; characters. The <TT>kind</TT> and <TT>id</TT> fields of
each component are separated by &#X2018;<TT>.</TT>&#X2019; characters. If the
<TT>kind</TT> field is empty, the representation has no trailing
&#X2018;<TT>.</TT>&#X2019;; if the <TT>id</TT> is empty, the representation starts
with a &#X2018;<TT>.</TT>&#X2019; character; if both <TT>id</TT> and <TT>kind</TT>
are empty, the representation is just a &#X2018;<TT>.</TT>&#X2019;. The backslash
&#X2018;<TT>\</TT>&#X2019; is used to escape the meaning of
&#X2018;<TT>/</TT>&#X2019;, &#X2018;<TT>.</TT>&#X2019; and &#X2018;<TT>\</TT>&#X2019; itself.</P><P><TT>to_url()</TT> takes a <TT>corbaloc</TT> style address and key string
(but without the <TT>corbaloc:</TT> part), and a stringified name,
and returns a <TT>corbaname</TT> URI (incorrectly called a URL)
string, having properly escaped any invalid characters. The
specification does not make it clear whether or not the address string
should also be escaped by the operation; omniORB does not escape
it. For this reason, it is best to avoid calling <TT>to_url()</TT> if the
address part contains escapable characters. To avoid remote calls,
omniORB provides the equivalent local function
<TT>omniURI::addrAndNameToURI()</TT>.</P><P><TT>resolve_str()</TT> is equivalent to calling <TT>to_name()</TT> followed by
the inherited <TT>resolve()</TT> operation. There are no string-based
equivalents of the various bind operations.</P><!--TOC subsection Use with corbaname-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc129">7.3.2</A>&#XA0;&#XA0;Use with corbaname</H3><!--SEC END --><P>To make it easy to use omniNames with <TT>corbaname</TT> URIs, it
starts with the default port of 2809, and an object key of
&#X2018;<TT>NameService</TT>&#X2019; for the root naming context.</P><!--TOC section omniMapper-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc130">7.4</A>&#XA0;&#XA0;omniMapper</H2><!--SEC END --><P>omniMapper is a simple daemon which listens on port 2809 (or any other
port), and redirects IIOP requests for configured object keys to
associated persistent object references. It can be used to make a
naming service (even an old non-INS aware version of omniNames or
other ORB&#X2019;s naming service) appear on port 2809 with the object key
&#X2018;<TT>NameService</TT>&#X2019;. The same goes for any other service you may
wish to specify, such as an interface repository. omniMapper is
started with a command line of:</P><BLOCKQUOTE CLASS="quote">
<TT>omniMapper [-port </TT>&lt;<I>port</I>&gt;<TT>] [-config </TT>&lt;<I>config file</I>&gt;<TT>] [-v]</TT>
</BLOCKQUOTE><P>The <TT>-port</TT> option allows you to choose a port other
than 2809 to listen on. The <TT>-config</TT> option specifies a
location for the configuration file. The default name is
<TT>/etc/omniMapper.cfg</TT>, or <TT>C:\omniMapper.cfg</TT> on
Windows. omniMapper does not normally print anything; the <TT>-v</TT>
option makes it verbose so it prints configuration information and a
record of the redirections it makes, to standard output.</P><P>The configuration file is very simple. Each line contains a string to
be used as an object key, some white space, and an IOR (or any valid
URI) that it will redirect that object key to. Comments should be
prefixed with a &#X2018;<TT>#</TT>&#X2019; character. For example:</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim"># Example omniMapper.cfg
NameService         IOR:000f...
InterfaceRepository IOR:0100...
</PRE></BLOCKQUOTE><P>omniMapper can either be run on a single machine, in much the same way
as omniNames, or it can be run on <EM>every</EM> machine, with a common
configuration file. That way, each machine&#X2019;s omniORB configuration
file could contain the line:</P><BLOCKQUOTE CLASS="quote">
<PRE CLASS="verbatim">ORBDefaultInitRef corbaloc::localhost
</PRE></BLOCKQUOTE><!--TOC section Creating objects with simple object keys-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc131">7.5</A>&#XA0;&#XA0;Creating objects with simple object keys</H2><!--SEC END --><P>In normal use, omniORB creates object keys containing various
information including POA names and various non-ASCII characters.
Since object keys are supposed to be opaque, this is not usually a
problem. The INS breaks this opacity and requires servers to create
objects with human-friendly keys.</P><P>If you wish to make your objects available with human-friendly URIs,
there are two options. The first is to use omniMapper as described
above, in conjunction with a <TT>PERSISTENT</TT> POA. The second is to
create objects with the required keys yourself. You do this with a
special POA with the name &#X2018;<TT>omniINSPOA</TT>&#X2019;, acquired from
<TT>resolve_initial_references()</TT>. This POA has the <TT>USER_ID</TT>
and <TT>PERSISTENT</TT> policies, and the special property that the
object keys it creates contain only the object ids given to the POA,
and no other data. It is a normal POA in all other respects, so you
can activate/deactivate it, create children, and so on, in the usual
way.</P><P>Children of the omniINSPOA do not inherit its special properties of
creating simple object keys. If the omniINSPOA&#X2019;s policies are not
suitable for your application, you cannot create a POA with different
policies (such as single threading, for example), and still generate
simple object keys. Instead, you can activate a servant in the
omniINSPOA that uses location forwarding to redirect requests to
objects in a different POA.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note14" HREF="#text14">1</A></DT><DD CLASS="dd-thefootnotes">Not 2089 as
printed in [<A HREF="#inschapters">OMG00</A>]!
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Code set conversion-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc132">Chapter&#XA0;8</A>&#XA0;&#XA0;Code set conversion</H1><!--SEC END --><P>
<A NAME="chap:codesets"></A></P><P>omniORB supports full code set negotiation, used to select and
translate between different character code sets when transmitting
chars, strings, wchars and wstrings. The support is mostly transparent
to application code, but there are a number of options that can be
selected. This chapter covers the options, and also gives some
pointers about how to implement your own code sets, in case the ones
that come with omniORB are not sufficient.</P><!--TOC section Native code sets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc133">8.1</A>&#XA0;&#XA0;Native code sets</H2><!--SEC END --><P>For the ORB to know how to handle strings and wstrings given to it by
the application, it must know what code set they are represented
with, so it can properly translate them if need be. The defaults are
ISO 8859-1 (Latin 1) for char and string, and UTF-16 for wchar and
wstring. Different code sets can be chosen at initialisation time with
the <TT>nativeCharCodeSet</TT> and <TT>nativeWCharCodeSet</TT>
parameters. The supported code sets are printed out at initialisation
time if the ORB traceLevel is 15 or greater.</P><P>For most applications, the defaults are fine. Some applications may
need to set the native char code set to UTF-8, allowing the full
Unicode range to be supported in strings.</P><P>Note that the default for wchar is always UTF-16, even on Unix
platforms where wchar is a 32-bit type. Select the UCS-4 code set to
select characters outside the first plane without having to use UTF-16
surrogates<SUP><A NAME="text15" HREF="#note15">1</A></SUP>.</P><!--TOC section Code set library-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc134">8.2</A>&#XA0;&#XA0;Code set library</H2><!--SEC END --><P>To save space in the main ORB core library, most of the code set
implementations are in a separate library named omniCodeSets4. To use
the extra code sets, you must link your application with that
library. On most platforms, if you are using dynamic linking,
specifying the omniCodeSets4 library in the link command is sufficient
to have it initialised, and for the code sets to be available. With
static linking, or platforms with less intelligent dynamic linkers,
you must force the linker to initialise the library. You do that by
including the <TT>omniORB4/optionalFeatures.h</TT> header. By default,
that header enables several optional features. Look at the file
contents to see how to turn off particular features.</P><!--TOC section Implementing new code sets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc135">8.3</A>&#XA0;&#XA0;Implementing new code sets</H2><!--SEC END --><P>It is quite easy to implement new code sets, if you need support for
code sets (or marshalling formats) that do not come with the omniORB
distribution. There are extensive comments in the headers and ORB code
that explain how to implement a code set; this section just serves to
point you in the right direction.</P><P>The main definitions for the code set support are in
<TT>include/omniORB4/codeSets.h</TT>. That defines a set of base classes
use to implement code sets, plus some derived classes that use look-up
tables to convert simple 8-bit and 16-bit code sets to Unicode.</P><P>When sending or receiving string data, there are a total of four code
sets in action: a native char code set, a transmission char code set,
a native wchar code set, and a transmission wchar code set. The native
code sets are as described above; the transmission code sets are the
ones selected to communicate with a remote machine. They are
responsible for understanding the GIOP marshalling formats, as well as
the code sets themselves. Each of the four code sets has an object
associated with it which contains methods for converting data.</P><P>There are two ways in which a string/wstring can be transmitted or
received. If the transmission code set in action knows how to deal
directly with the native code set (the trivial case being that they
are the same code set, but more complex cases are possible too), the
transmission code set object can directly marshal or unmarshal the
data into or out of the application buffer. If the transmission code
set does not know how to handle the native code set, it converts the
string/wstring into UTF-16, and passes that to the native code set
object (or vice-versa). All code set implementations must therefore
know how to convert to and from UTF-16.</P><P>With this explanation, the classes in <TT>codeSets.h</TT> should be easy
to understand. The next place to look is in the various existing code
set implementations, which are files of the form <TT>cs-*.cc</TT> in the
<TT>src/lib/omniORB/orbcore</TT> and <TT>src/lib/omniORB/codesets</TT>.
Note how all the 8-bit code sets (the ISO 8859-* family) consist
entirely of data and no code, since they are driven by look-up tables.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note15" HREF="#text15">1</A></DT><DD CLASS="dd-thefootnotes">If you have no idea what this means, don&#X2019;t
worry&#X2014;you&#X2019;re better off not knowing unless you <EM>really</EM> have
to.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Interceptors-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc136">Chapter&#XA0;9</A>&#XA0;&#XA0;Interceptors</H1><!--SEC END --><P>
<A NAME="chap:interceptors"></A></P><P>omniORB supports interceptors that allow the application to insert
processing in various points along the call chain, and in various
other locations. It does not (yet) support the standard Portable
Interceptors API.</P><P>The interceptor interfaces are defined in a single header,
<TT>include/omniORB4/omniInterceptors.h</TT>. Each interception point
consists of a singleton object with <TT>add()</TT> and <TT>remove()</TT> methods,
and the definition of an &#X2018;interceptor info&#X2019; class. For example:</P><DIV CLASS="lstlisting"><B>class</B> omniInterceptors {
  ...
  <B>class</B> clientSendRequest_T {
  <B>public</B>:

    <B>class</B> info_T {
    <B>public</B>:
      GIOP_C&amp;                 giop_c;
      IOP::ServiceContextList service_contexts;

      info_T(GIOP_C&amp; c) : giop_c(c), service_contexts(5) {}

    <B>private</B>:
      info_T();
      info_T(<B>const</B> info_T&amp;);
      info_T&amp; <B>operator</B>=(<B>const</B> info_T&amp;);
    };

    <B>typedef</B> CORBA::Boolean (*interceptFunc)(info_T&amp; info);

    <B>void</B> add(interceptFunc);
    <B>void</B> remove(interceptFunc);
  };
  ...
};</DIV><P>You can see that the interceptors themselves are functions
that take the <TT>info_T</TT> object as their argument and return
boolean. Interceptors are called in the order they are registered;
normally, all interceptor functions return <TT>true</TT>, meaning that
processing should continue with subsequent interceptors. If an
interceptor returns <TT>false</TT>, later interceptors are not
called. You should only do that if you really know what you are doing.</P><P>Notice that the <TT>info_T</TT> contains references to omniORB internal
data types. The definitions of these types can be found in other
header files within <TT>include/omniORB4</TT> and
<TT>include/omniORB4/internal</TT>.</P><!--TOC section Interceptor registration-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc137">9.1</A>&#XA0;&#XA0;Interceptor registration</H2><!--SEC END --><P>All the interceptor singletons are registered within another singleton
object of class <TT>omniInterceptors</TT>. You retrieve a pointer to the
object with the <TT>omniORB::getInterceptors()</TT> function, which
must be called after the ORB has been initialised with
<TT>CORBA::ORB_init()</TT>, but before the ORB is used. The code to
register an interceptor looks, for example, like:</P><DIV CLASS="lstlisting">omniInterceptors* interceptors = omniORB::getInterceptors();
interceptors-&gt;clientSendRequest.add(myInterceptorFunc);</DIV><!--TOC section Available interceptors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc138">9.2</A>&#XA0;&#XA0;Available interceptors</H2><!--SEC END --><P>The following interceptors are available:</P><DL CLASS="description"><DT CLASS="dt-description"><B>encodeIOR</B></DT><DD CLASS="dd-description"><BR>
Called when encoding an IOR to represent an object reference. This
interception point allows the application to insert extra profile
components into IORs. Note that you must understand and adhere to the
rules about data stored in IORs, otherwise the IORs created may be
invalid. omniORB itself uses this interceptor to insert various items,
so you can see an example of its use in the
<TT>insertSupportedComponents()</TT> function defined in
<TT>src/lib/omniORB/orbcore/ior.cc</TT>.</DD><DT CLASS="dt-description"><B>decodeIOR</B></DT><DD CLASS="dd-description"><BR>
Called when decoding an IOR. The application can use this to get out
whatever information they put into IORs with encodeIOR. Again, see
<TT>extractSupportedComponents()</TT> in
<TT>src/lib/omniORB/orbcore/ior.cc</TT> for an example.</DD><DT CLASS="dt-description"><B>clientOpenConnection</B></DT><DD CLASS="dd-description"><BR>
Called as a client opens a new connection to a server, after the
connection is opened but before it is used to send a request. The
interceptor function can set the <TT>info_T</TT>&#X2019;s <TT>reject</TT> member
to <TT>true</TT> to cause the client to immediately close the new
connection and throw CORBA::TRANSIENT to the calling code. In that
case, the interceptor function can also set the <TT>why</TT> member to
provide a message that is logged.</DD><DT CLASS="dt-description"><B>clientSendRequest</B></DT><DD CLASS="dd-description"><BR>
Called just before a request header is sent over the network. The
application can use it to insert service contexts in the header. See
the <TT>setCodeSetServiceContext()</TT> function in
<TT>src/lib/omniORB/orbcore/cdrStream.cc</TT> for an example of its use.</DD><DT CLASS="dt-description"><B>clientReceiveReply</B></DT><DD CLASS="dd-description"><BR>
Called as the client receives a reply, just after unmarshalling the
reply header. Called for normal replies and exceptions.</DD><DT CLASS="dt-description"><B>serverAcceptConnection</B></DT><DD CLASS="dd-description"><BR>
Called when a server accepts a new incoming connection, but before it
reads any data from it. The interceptor function can set the
<TT>info_T</TT>&#X2019;s <TT>reject</TT> member to <TT>true</TT> to cause the
server to immediately close the new connection. In that case, the
interceptor function can also set the <TT>why</TT> member to provide a
message that is logged.</DD><DT CLASS="dt-description"><B>serverReceiveRequest</B></DT><DD CLASS="dd-description"><BR>
Called when the server receives a request, just after unmarshalling
the request header. See the <TT>getCodeSetServiceContext()</TT> function in
<TT>src/lib/omniORB/orbcore/cdrStream.cc</TT> for an example.</DD><DT CLASS="dt-description"><B>serverSendReply</B></DT><DD CLASS="dd-description"><BR>
Called just before the server marshals a reply header.</DD><DT CLASS="dt-description"><B>serverSendException</B></DT><DD CLASS="dd-description"><BR>
Called just before the server marshals an exception reply header.</DD><DT CLASS="dt-description"><B>createRope</B></DT><DD CLASS="dd-description"><BR>
Called when the ORB is about to create a &#X2018;rope&#X2019; that encapsulates a
bundle of connections (&#X2018;strands&#X2019;) to a remote address space. It allows
application code to override omniORB&#X2019;s normal connection management.</DD><DT CLASS="dt-description"><B>createIdentity</B></DT><DD CLASS="dd-description"><BR>
Called when the ORB is about to create an &#X2018;identity&#X2019; object to
represent a CORBA object. It allows application code to provide its
own identity implementations. It is very unlikely that an application
will need to do this.</DD><DT CLASS="dt-description"><B>createORBServer</B></DT><DD CLASS="dd-description"><BR>
Used internally by the ORB to register different kinds of server. At
present, only a GIOP server is registered. It is very unlikely that
application code will need to do this.</DD><DT CLASS="dt-description"><B>createThread</B></DT><DD CLASS="dd-description"><BR>
Called whenever the ORB creates a thread. The <TT>info_T</TT> class for
this interceptor is<DIV CLASS="lstlisting">    <B>class</B> info_T {
    <B>public</B>:
      <B>virtual</B> <B>void</B> run() = 0;
      <B>virtual</B> omni_thread* self() = 0;
    };</DIV><P>The interceptor is called in the context of the newly created thread.
The function <EM>must</EM> call the <TT>info_T</TT>&#X2019;s <TT>run()</TT> method, to
pass control to the thread body. <TT>run()</TT> returns just before the
thread exits. This arrangement allows the interceptor to initialise
some per-thread state before the thread body runs, then release it
just before the thread exits.</P><P>The <TT>info_T</TT>&#X2019;s <TT>self()</TT> method returns a pointer to the
<TT>omni_thread</TT> object for the thread, equivalent to calling
<TT>omni_thread::self()</TT>.</P></DD><DT CLASS="dt-description"><B>assignUpcallThread</B></DT><DD CLASS="dd-description"><BR>
The ORB maintains a general thread pool, from which threads are drawn
for various purposes. One purpose is for performing upcalls to
application code, in response to incoming CORBA calls. The
<TT>assignUpcallThread</TT> interceptor is called when a thread is
assigned to perform upcalls. In the thread per connection model, the
thread stays assigned to performing upcalls for the entire lifetime of
the underlying network connection; in the thread pool model, threads
are assigned for upcalls on a per call basis, so this interceptor is
triggered for every incoming call<SUP><A NAME="text16" HREF="#note16">1</A></SUP>. As with the <TT>createThread</TT> interceptor, the
interceptor function must call the <TT>info_T</TT>&#X2019;s <TT>run()</TT> method to
pass control to the upcall.<P>When a thread finishes its assignment of processing upcalls, it
returns to the pool (even in thread per connection mode), so the same
thread can be reassigned to perform more upcalls, or reused for a
different purpose.</P></DD><DT CLASS="dt-description"><B>assignAMIThread</B></DT><DD CLASS="dd-description"><BR>
Asynchronous Method Invocation (AMI) uses threads to perform outgoing
calls. The <TT>assignAMIThread</TT> interceptor is called when a thread
is assigned to perform AMI calls. As with the other thread
interceptors, the interceptor function must call the <TT>info_T</TT>&#X2019;s
<TT>run()</TT> method to pass control to the AMI call.<P>Unlike the other interceptors, the interceptor functions for
<TT>createThread</TT>, <TT>assignUpcallThread</TT> and
<TT>assignAMIThread</TT> have no return values. Interceptor chaining is
performed by calls through the <TT>info_T::run()</TT> method, rather than
by visiting interceptor functions in turn.</P></DD></DL><!--TOC section Server-side call interceptor-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc139">9.3</A>&#XA0;&#XA0;Server-side call interceptor</H2><!--SEC END --><P>Calls can be intercepted on the server just before the upcall into
application code. This interceptor is registered with omniORB&#X2019;s
<TT>callDescriptor</TT> class, which is responsible for encapsulating
the state of a call. Unlike the transport-related
<TT>serverReceiveRequest</TT>, <TT>serverSendReply</TT> and
<TT>serverSendException</TT> interceptors, the <TT>callDescriptor</TT>
interceptor is invoked for <EM>all</EM> calls, even ones from colocated
clients in the same address space.</P><P>The types used for the call interceptor are defined in
<TT>include/omniORB4/callDescriptor.h</TT>. The interceptor takes the
form of a bare function with two parameters. The first parameter is a
pointer to the <TT>callDescriptor</TT>; the second is a pointer to
<TT>omniServant</TT>, which is the base class of all servant
classes. The interceptor function must call the
<TT>callDescriptor</TT>&#X2019;s <TT>interceptedCall()</TT> method to pass on the
call.</P><P>This interception point allows access to various parts of omniORB&#X2019;s
call machinery. The <TT>callDescriptor</TT> includes access to the
operation name and, if cast to the concrete subclass defined by the
IDL compiler, the call arguments and return values too.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note16" HREF="#text16">1</A></DT><DD CLASS="dd-thefootnotes">Except that with the
<TT>threadPoolWatchConnection</TT> parameter set <TT>true</TT>, a thread
can perform multiple upcalls even when thread pool mode is
active.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Type Any and TypeCode-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc140">Chapter&#XA0;10</A>&#XA0;&#XA0;Type Any and TypeCode</H1><!--SEC END --><P>
<A NAME="chap:any"></A></P><P>The CORBA specification provides for a type that can hold the value of
any OMG IDL type. This type is known as type <TT>Any</TT>. The OMG also
specifies a pseudo-object, <TT>TypeCode</TT>, that can encode a
description of any type specifiable in OMG IDL.</P><P>In this chapter, an example demonstrating the use of type Any is
presented. The example code is in the <TT>src/examples/anyExample</TT>
directory in the omniORB distribution. The example is followed by
sections describing the behaviour of type Any and TypeCode in omniORB.
For further information on type Any, refer to the C++ Mapping
specification., and for more information on TypeCode, refer to the
Interface Repository chapter in the CORBA core section of the CORBA
specification.</P><!--TOC section Example using type Any-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc141">10.1</A>&#XA0;&#XA0;Example using type Any</H2><!--SEC END --><P>Before going through this example, you should make sure that you have
read and understood the examples in chapter&#XA0;<A HREF="#chap:basic">2</A>.</P><!--TOC subsection Type Any in IDL-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc142">10.1.1</A>&#XA0;&#XA0;Type Any in IDL</H3><!--SEC END --><P>
Type Any allows one to delay the decision on the type used in an
operation until run-time. To use type any in IDL, use the keyword
<TT>any</TT>, as in the following example:</P><DIV CLASS="lstlisting"><I>// IDL</I>
<B>interface</B> anyExample {
  <B>any</B> testOp(<B>in</B> <B>any</B> mesg);
};</DIV><P>The operation <TT>testOp()</TT> in this example can now take any
value expressible in OMG IDL as an argument, and can also return any
type expressible in OMG IDL.</P><P>Type Any is mapped into C++ as the type <TT>CORBA::Any</TT>. When passed
as an argument or as a result of an operation, the following rules
apply:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><B>In </B></TD><TD ALIGN=left NOWRAP><B>InOut </B></TD><TD ALIGN=left NOWRAP><B>Out </B></TD><TD ALIGN=left NOWRAP><B>Return </B></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=4></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>const CORBA::Any&amp; </TT></TD><TD ALIGN=left NOWRAP><TT>CORBA::Any&amp; </TT></TD><TD ALIGN=left NOWRAP><TT>CORBA::Any*&amp; </TT></TD><TD ALIGN=left NOWRAP><TT>CORBA::Any* </TT></TD></TR>
</TABLE><P>So, the above IDL would map to the following C++:</P><DIV CLASS="lstlisting"><I>// C++</I>

<B>class</B> anyExample_i : <B>public</B> <B>virtual</B> POA_anyExample {
<B>public</B>:
  anyExample_i() { }
  <B>virtual</B> ~anyExample_i() { }
  <B>virtual</B> CORBA::Any* testOp(<B>const</B> CORBA::Any&amp; a);
};</DIV><!--TOC subsection Inserting and Extracting Basic Types from an Any-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc143">10.1.2</A>&#XA0;&#XA0;Inserting and Extracting Basic Types from an Any</H3><!--SEC END --><P>The question now arises as to how values are inserted into and removed
from an Any. This is achieved using two overloaded operators:
<TT>&lt;&lt;=</TT> and <TT>&gt;&gt;=</TT>.</P><P>To insert a value into an Any, the <TT>&lt;&lt;=</TT> operator is used, as
in this example:</P><DIV CLASS="lstlisting"><I>// C++</I>
CORBA::Any an_any;
CORBA::Long l = 100;
an_any &lt;&lt;= l;</DIV><P>Note that the overloaded <TT>&lt;&lt;=</TT> operator has a return
type of <TT>void</TT>.</P><P>To extract a value, the <TT>&gt;&gt;=</TT> operator is used, as in this
example (where the Any contains a long):</P><DIV CLASS="lstlisting"><I>// C++</I>
CORBA::Long l;
an_any &gt;&gt;= l;

cout &lt;&lt; "This is a long: " &lt;&lt; l &lt;&lt; endl;</DIV><P>The overloaded <TT>&gt;&gt;=</TT> operator returns a <TT>CORBA::Boolean</TT>.
If an attempt is made to extract a value from an Any when it contains
a different type of value (e.g. an attempt to extract a long from an
Any containing a double), the overloaded <TT>&gt;&gt;=</TT> operator will
return <TT>false</TT>; otherwise it will return <TT>true</TT>. Thus, a
common tactic to extract values from an Any is as follows:</P><DIV CLASS="lstlisting"><I>// C++</I>
CORBA::Long l;
CORBA::Double d;
<B>const</B> <B>char</B>* str;

<B>if</B> (an_any &gt;&gt;= l) {
  cout &lt;&lt; "Long: " &lt;&lt; l &lt;&lt; endl;
}
<B>else</B> <B>if</B> (an_any &gt;&gt;= d) {
  cout &lt;&lt; "Double: " &lt;&lt; d &lt;&lt; endl;
}
<B>else</B> <B>if</B> (an_any &gt;&gt;= str) {
  cout &lt;&lt; "String: " &lt;&lt; str &lt;&lt; endl;
  <I>// The storage of the extracted string is still owned by the any.</I>
}
<B>else</B> {
  cout &lt;&lt; "Unknown value." &lt;&lt; endl;
}</DIV><!--TOC subsection Inserting and Extracting Constructed Types from an Any-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">10.1.3</A>&#XA0;&#XA0;Inserting and Extracting Constructed Types from an Any</H3><!--SEC END --><P>It is also possible to insert and extract constructed types and object
references from an Any. omniidl will generate insertion and extraction
operators for the constructed type. Note that it is necessary to
specify the <TT>-Wba</TT> command-line flag when running omniidl in
order to generate these operators. The following example illustrates
the use of constructed types with type Any:</P><DIV CLASS="lstlisting"><I>// IDL</I>
<B>struct</B> testStruct {
  <B>long</B> l;
  <B>short</B> s;
};

<B>interface</B> anyExample {
  <B>any</B> testOp(<B>in</B> <B>any</B> mesg);
};</DIV><P>Upon compiling the above IDL with <TT>omniidl -bcxx -Wba</TT>, the
following overloaded operators are generated:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>void operator&lt;&lt;=(CORBA::Any&amp;, const testStruct&amp;)</CODE>
</LI><LI CLASS="li-enumerate"><CODE>void operator&lt;&lt;=(CORBA::Any&amp;, testStruct*)</CODE>
</LI><LI CLASS="li-enumerate"><CODE>CORBA::Boolean operator&gt;&gt;=(const CORBA::Any&amp;,</CODE><BR>
 <CODE>const testStruct*&amp;)</CODE>
</LI></OL><P>Operators of this form are generated for all constructed types, and
for interfaces.</P><P>The first operator, <EM>(1)</EM>, copies the constructed type, and
inserts it into the Any. The second operator, <EM>(2)</EM>, inserts the
constructed type into the Any, and then manages it. Note that if the
second operator is used, the Any consumes the constructed type, and
the caller should not use the pointer to access the data after
insertion. The following is an example of how to insert a value into
an Any using operator <EM>(1)</EM>:</P><DIV CLASS="lstlisting"><I>// C++</I>
CORBA::Any an_any;

testStruct t;
t.l = 456;
t.s = 8;

an_any &lt;&lt;= t;</DIV><P>The third operator, <EM>(3)</EM>, is used to extract the constructed
type from the Any, and can be used as follows:</P><DIV CLASS="lstlisting"><B>const</B> testStruct* tp;

<B>if</B> (an_any &gt;&gt;= tp) {
    cout &lt;&lt; "testStruct: l: " &lt;&lt; tp-&gt;l &lt;&lt; endl;
    cout &lt;&lt; "            s: " &lt;&lt; tp-&gt;s &lt;&lt; endl;
}
<B>else</B> {
    cout &lt;&lt; "Unknown value contained in Any." &lt;&lt; endl;
}</DIV><P>As with basic types, if an attempt is made to extract a type from an
Any that does not contain a value of that type, the extraction
operator returns <TT>false</TT>. If the Any does contain that type, the
extraction operator returns <TT>true</TT>. If the extraction is
successful, the caller&#X2019;s pointer will point to memory managed by the
Any. The caller must not delete or otherwise change this storage, and
should not use this storage after the contents of the Any are replaced
(either by insertion or assignment), or after the Any has been
destroyed. In particular, management of the pointer should not be
assigned to a <TT>_var</TT> type.</P><P>If the extraction fails, the caller&#X2019;s pointer will be set to point to
null.</P><P>Note that there are special rules for inserting and extracting arrays
(using the <TT>_forany</TT> types), and for inserting and extracting
bounded strings, booleans, chars, and octets. Please refer to the C++
Mapping specification for further information.</P><!--TOC section Type Any in omniORB-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc145">10.2</A>&#XA0;&#XA0;Type Any in omniORB</H2><!--SEC END --><P>
<A NAME="anyOmniORB"></A></P><P>This section contains some notes on the use and behaviour of type Any
in omniORB.</P><!--TOC subsection Generating Insertion and Extraction Operators.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">10.2.1</A>&#XA0;&#XA0;Generating Insertion and Extraction Operators.</H3><!--SEC END --><P>
To generate type Any insertion and extraction operators for
constructed types and interfaces, the <TT>-Wba</TT> command line flag
should be specified when running omniidl.</P><!--TOC subsection TypeCode comparison when extracting from an Any.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">10.2.2</A>&#XA0;&#XA0;TypeCode comparison when extracting from an Any.</H3><!--SEC END --><P>
When an attempt is made to extract a type from an Any, the TypeCode of
the type is checked for <EM>equivalence</EM> with the TypeCode of the
type stored by the Any. The <TT>equivalent()</TT> test in the TypeCode
interface is used for this purpose. For example:</P><DIV CLASS="lstlisting"><I>// IDL 1</I>
<B>typedef</B> <B>double</B> Double1;

<B>struct</B> Test1 {
  Double1 a;
};</DIV><DIV CLASS="lstlisting"><I>// IDL 2</I>
<B>typedef</B> <B>double</B> Double2;

<B>struct</B> Test1 {
  Double2 a;
};</DIV><P>If an attempt is made to extract the type <TT>Test1</TT> defined in IDL
1 from an Any containing the <TT>Test1</TT> defined in IDL 2, this will
succeed (and vice-versa), as the two types differ only by an alias.</P><!--TOC subsection Top-level aliases.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc148">10.2.3</A>&#XA0;&#XA0;Top-level aliases.</H3><!--SEC END --><P>
When a type is inserted into an Any, the Any stores both the value of
the type and the TypeCode for that type. However, in some cases, a
top-level alias can be lost due to the details of the C++ mapping. For
example, consider these IDL definitions:</P><DIV CLASS="lstlisting"><I>// IDL 3</I>
<B>typedef</B> <B>sequence</B>&lt;<B>double</B>&gt; seqDouble1;
<B>typedef</B> <B>sequence</B>&lt;<B>double</B>&gt; seqDouble2;
<B>typedef</B> seqDouble2       seqDouble3;</DIV><P>omniidl generates distinct types for <TT>seqDouble1</TT> and
<TT>seqDouble2</TT>, and therefore each has its own set of C++ operators
for Any insertion and extraction. That means inserting a
<TT>seqDouble1</TT> into an Any sets the Any&#X2019;s TypeCode to include the
alias &#X2018;seqDouble1&#X2019;, and inserting a <TT>seqDouble2</TT> sets the
TypeCode to the alias &#X2018;seqDouble2&#X2019;.</P><P>However, in the C++ mapping, <TT>seqDouble3</TT> is required to be just
a C++ typedef to <TT>seqDouble2</TT>, so the C++ compiler uses the Any
insertion operator for <TT>seqDouble2</TT>. Therefore, inserting a
<TT>seqDouble3</TT> sets the Any&#X2019;s TypeCode to the <TT>seqDouble2</TT>
alias. If this is not desirable, you can use the member function
&#X2018;<TT>void type(TypeCode_ptr)</TT>&#X2019; of the Any interface to explicitly
set the TypeCode to the correct one.</P><!--TOC subsection Removing aliases from TypeCodes.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc149">10.2.4</A>&#XA0;&#XA0;Removing aliases from TypeCodes.</H3><!--SEC END --><P>
Some ORBs (such as old versions of Orbix) will not accept TypeCodes
containing <TT>tk_alias</TT> TypeCodes. When using type Any while
interoperating with these ORBs, it is necessary to remove
<TT>tk_alias</TT> TypeCodes from throughout the TypeCode representing a
constructed type.</P><P>To remove all <TT>tk_alias</TT> TypeCodes from TypeCodes transmitted in
Anys, supply the <TT>-ORBtcAliasExpand 1</TT> command-line flag when
running an omniORB executable. There will be some (small) performance
penalty when transmitting Any values.</P><P>Note that the <TT>_tc_</TT> TypeCodes generated for all constructed
types will contain the complete TypeCode for the type (including any
<TT>tk_alias</TT> TypeCodes), regardless of whether the
<TT>-ORBtcAliasExpand</TT> flag is set to 1 or not. It is only when
Anys are transmitted that the aliases are stripped.</P><!--TOC subsection Recursive TypeCodes.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc150">10.2.5</A>&#XA0;&#XA0;Recursive TypeCodes.</H3><!--SEC END --><P>
omniORB supports recursive TypeCodes. This means that types such as
the following can be inserted or extracted from an Any:</P><DIV CLASS="lstlisting"><I>// IDL 4</I>
<B>struct</B> Test4 {
  <B>sequence</B>&lt;Test4&gt; a;
};</DIV><!--TOC subsection Threads and type Any.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc151">10.2.6</A>&#XA0;&#XA0;Threads and type Any.</H3><!--SEC END --><P>
Inserting and extracting simultaneously from the same Any (in 2
threads) results in undefined behaviour.</P><P>In versions of omniORB before 4.0, extracting simultaneously from the
same Any (in 2 or more different threads) also led to undefined
behaviour. That is no longer the case&#X2014;Any extraction is now thread
safe.</P><!--TOC section TypeCode in omniORB-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc152">10.3</A>&#XA0;&#XA0;TypeCode in omniORB</H2><!--SEC END --><P>This section contains some notes on the use and behaviour of TypeCode
in omniORB</P><!--TOC subsection TypeCodes in IDL.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">10.3.1</A>&#XA0;&#XA0;TypeCodes in IDL.</H3><!--SEC END --><P>When using TypeCodes in IDL, note that they are defined in the CORBA
scope. Therefore, <TT>CORBA::TypeCode</TT> should be used. Example:</P><DIV CLASS="lstlisting"><I>// IDL 5</I>
<B>struct</B> Test5 {
  <B>long</B> length;
  CORBA::TypeCode desc;
};</DIV><!--TOC subsection orb.idl-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc154">10.3.2</A>&#XA0;&#XA0;orb.idl</H3><!--SEC END --><P>The CORBA specification says that IDL using <TT>CORBA::TypeCode</TT>
must include the file <TT>orb.idl</TT>. That is not required in omniORB,
but a suitable <TT>orb.idl</TT> is available.</P><!--TOC subsection Generating TypeCodes for constructed types.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc155">10.3.3</A>&#XA0;&#XA0;Generating TypeCodes for constructed types.</H3><!--SEC END --><P>To generate a TypeCode for constructed types, specify the
<TT>-Wba</TT> command-line flag when running omniidl. This will
generate a <TT>_tc_</TT> TypeCode describing the type, at the same
scope as the type. Example:</P><DIV CLASS="lstlisting"><I>// IDL 6</I>
<B>struct</B> Test6 {
  <B>double</B> a;
  <B>sequence</B>&lt;<B>long</B>&gt; b;
};</DIV><P>A TypeCode, <TT>_tc_Test6</TT>, will be generated to describe the
struct <TT>Test6</TT>. The operations defined in the TypeCode interface
can be used to query the TypeCode about the type it represents.</P><!--TOC chapter Objects by value, etc.-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc156">Chapter&#XA0;11</A>&#XA0;&#XA0;Objects by value, abstract interfaces and local interfaces</H1><!--SEC END --><P>
<A NAME="chap:valuetype"></A></P><P>omniORB 4.1 supports objects by value, declared with the
<TT>valuetype</TT> keyword in IDL, and both abstract and local
interfaces. This chapter outlines some issues to do with using these
types in omniORB. You are assumed to have read the relevant parts of
the CORBA specification, specifically chapters 3, 4, 5 and 6 of the
CORBA 2.6 specification, and sections 1.17, 1.18 and 1.35 of the C++
mapping specification, version 1.1.</P><!--TOC section Features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc157">11.1</A>&#XA0;&#XA0;Features</H2><!--SEC END --><P>omniORB supports the complete objects by value specification, with the
exception of custom valuetypes. All other valuetype features including
value boxes, value sharing semantics, abstract valuetypes, and
abstract interfaces are supported. Local interfaces are supported,
with a number of caveats outlined in
section&#XA0;<A HREF="#sec:LocalInterfaces">11.8</A>.</P><!--TOC section Reference counting-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc158">11.2</A>&#XA0;&#XA0;Reference counting</H2><!--SEC END --><P>Values are reference counted. This means that, as long as your
application properly manages reference counts, values are usually
automatically deleted when they are no longer required. However, one
of the features of valuetypes is that they support the representation
of cyclic graph structures. In that kind of situation, the reference
counting garbage collection does not work, because references internal
to the graph prevent the reference counts ever becoming zero.</P><P>To avoid memory leaks, application code must explicitly break any
reference cycles in values it manipulates. This includes graphs of
values received as parameters and return values from CORBA operations.</P><!--TOC section Value sharing and local calls-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc159">11.3</A>&#XA0;&#XA0;Value sharing and local calls</H2><!--SEC END --><P>When valuetypes are passed as parameters in CORBA calls (i.e. calls
on CORBA objects declared with <TT>interface</TT> in IDL), the structure
of related values is maintained. Consider, for example, the following
IDL definitions (which are from the example code in
<TT>src/examples/valuetype/simple</TT>:</P><DIV CLASS="lstlisting"><B>module</B> ValueTest {
  <B>valuetype</B> One {
    <B>public</B> <B>string</B> s;
    <B>public</B> <B>long</B>   l;
  };

  <B>interface</B> Test {
    One op1(<B>in</B> One a, <B>in</B> One b);
  };
};</DIV><P>If the client to the <TT>Test</TT> object passes the same value in both
parameters, just one value is transmitted, and the object
implementation receives a copy of the single value, with references to
it in both parameters.</P><P>In the case that the object is remote from the client, there is
obviously a copying step involved. In the case that the object is in
the same address space as the client, the same copying semantics must
be maintained so that the object implementation can modify the values
it receives without the client seeing the modifications. To support
that, omniORB must copy the entire parameter list in one operation, in
case there is sharing between different parameters. Such copying is a
rather more time-consuming process than the parameter-by-parameter
copy that takes place in calls not involving valuetypes.</P><P>To avoid the overhead of copying parameters in this way, applications
can choose to relax the semantics of value copying in local calls, so
values are not copied at all, but are passed by reference. In that
case, the client to a call <EM>will</EM> see any modifications to the
values it passes as parameters (and similarly, the object
implementation will see any changes the client makes to returned
values). To choose this option, set the <TT>copyValuesInLocalCalls</TT>
configuration parameter to zero.</P><!--TOC section Value box factories-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc160">11.4</A>&#XA0;&#XA0;Value box factories</H2><!--SEC END --><P>With normal valuetypes, omniidl generates factory classes (with names
ending <TT>_init</TT>) as required by the C++ mapping specification.
The application is responsible for registering the factories with the
ORB.</P><P>Unfortunately, the C++ mapping makes no mention of factories for value
boxes. In omniORB, factories for value boxes are automatically
registered with the ORB, and there are no application-visible factory
classes generated for them. Some other CORBA implementations generate
application visible factories, and the application <EM>does</EM> have to
register the factories with the ORB.</P><!--TOC section Standard value boxes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc161">11.5</A>&#XA0;&#XA0;Standard value boxes</H2><!--SEC END --><P>The standard <TT>CORBA::StringValue</TT> and <TT>CORBA::WStringValue</TT>
value boxes are available to application code. To make the definitions
available in IDL, #include the standard <TT>orb.idl</TT>.</P><!--TOC section Covariant returns-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc162">11.6</A>&#XA0;&#XA0;Covariant returns</H2><!--SEC END --><P>As required by the C++ mapping, on C++ compilers that support
covariant return types, omniidl generates code for the
<TT>_copy_value()</TT> function that returns the most derived type of the
value. On older compilers, <TT>_copy_value()</TT> returns
<TT>CORBA::ValueBase</TT>.</P><P>If you write code that calls <TT>_copy_value()</TT>, and you need to
support older compilers, you should assign the result to a variable of
type <TT>CORBA::ValueBase*</TT> and downcast to the target type, rather
than using the covariant return.</P><P>If you are overriding <TT>_copy_value()</TT>, you must correctly take
account of the <TT>OMNI_HAVE_COVARIANT_RETURNS</TT> preprocessor
definition.</P><!--TOC section Values inside Anys-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc163">11.7</A>&#XA0;&#XA0;Values inside Anys</H2><!--SEC END --><P>Valuetypes inserted into Anys cause a number of interesting issues.
Even when inside Anys, values are required to support complete sharing
semantics. Take this IDL for example:</P><DIV CLASS="lstlisting"><B>module</B> ValueTest {
  <B>valuetype</B> One {
    <B>public</B> <B>string</B> s;
    <B>public</B> <B>long</B>   l;
  };

  <B>interface</B> AnyTest {
    <B>void</B> op1(<B>in</B> One v, <B>in</B> Any a);
  };
};</DIV><P>Now, suppose the client behaves as follows:</P><DIV CLASS="lstlisting">ValueTest::One* v = <B>new</B> One_impl("hello", 123);
CORBA::Any a;
a &lt;&lt;= v;
obj-&gt;op1(v, a);</DIV><P>then on the server side:</P><DIV CLASS="lstlisting"><B>void</B> AnyTest_impl::op1(ValueTest::One* v, CORBA::Any&amp; a)
{
  ValueTest::One* v2;
  a &gt;&gt;= v2;
  assert(v2 == v);
}</DIV><P>This is all very well in this kind of simple situation, but problems
can arise if truncatable valuetypes are used. Imagine this derived
value:</P><DIV CLASS="lstlisting"><B>module</B> ValueTest {
  <B>valuetype</B> Two : <B>truncatable</B> One {
    <B>public</B> <B>double</B> d;
  };
};</DIV><P>Now, suppose that the client shown above sends an instance of
valuetype <TT>Two</TT> in both parameters, and suppose that the server
has not seen the definition of valuetype <TT>Two</TT>. In this
situation, as the first parameter is unmarshalled, it will be
truncated to valuetype <TT>One</TT>, as required. Now, when the Any is
unmarshalled, it refers to the same value, which has been truncated.
So, even though the TypeCode in the Any indicates that the value has
type <TT>Two</TT>, the stored value actually has type <TT>One</TT>. If the
receiver of the Any tries to pass it on, transmission will fail
because the Any&#X2019;s value does not match its TypeCode.</P><P>In the opposite situation, where an Any parameter comes before a
valuetype parameter, a different problem occurs. In that case, as the
Any is unmarshalled, there is no type information available for
valuetype <TT>Two</TT>, so the value inside the Any has an internal
omniORB type used for unknown valuetypes. As the next parameter is
unmarshalled, omniORB sees that the shared value is unknown, and is
able to convert it to the target <TT>One</TT> valuetype with
truncation. In this case, the Any and the plain valuetype both have
the correct types and values, but the fact that both should have
referred to the same value has been lost.</P><P>Because of these issues, it is best to avoid defining interfaces that
mix valuetypes and Anys in a single operation, and certainly to avoid
trying to share plain values with values inside Anys.</P><!--TOC subsection Values inside DynAnys-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc164">11.7.1</A>&#XA0;&#XA0;Values inside DynAnys</H3><!--SEC END --><P>The sharing semantics of valuetypes can also cause difficulties for
DynAny. The CORBA 2.6 specification does not mention how shared values
inside DynAnys should be handled; the CORBA 3.x specification slightly
clarifies the situation, but it is still unclear. To write portable
code it is best to avoid manipulating DynAnys containing values that
are shared.</P><P>In omniORB, when a value inside an Any is converted into a DynAny, the
value&#X2019;s state is copied into the DynAny, and manipulated there. When
converting back to an Any a new value is created. This means that any
other references to the original value (whether themselves inside Anys
of not) still relate to the original value, with unchanged state.
However, this copying only occurs when a DynValue is actually created,
so for example a structure with two value members referring to the
same value can manipulated inside a DynAny without breaking the
sharing, provided the value members are not accessed as DynAnys.
Extracting the value members as ValueBase will reveal the sharing, for
example.</P><!--TOC section Local Interfaces-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc165">11.8</A>&#XA0;&#XA0;Local Interfaces</H2><!--SEC END --><P>
<A NAME="sec:LocalInterfaces"></A></P><P>Local interfaces are somewhat under-specified in the C++ mapping. This
section outlines the way local interfaces are supported in omniORB,
and details the limitations and issues.</P><!--TOC subsection Simple local interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc166">11.8.1</A>&#XA0;&#XA0;Simple local interfaces</H3><!--SEC END --><P>With simple IDL, there are no particular issues:</P><DIV CLASS="lstlisting"><B>module</B> Test {
  <B>local</B> <B>interface</B> Example {
    <B>string</B> hello(<B>in</B> <B>string</B> arg);
  };
};</DIV><P>The IDL compiler generates an abstract base class
<TT>Test::Example</TT>. The application defines a class derived from it
that implements the abstract <TT>hello()</TT> member function. Instances of
that class can then be used where the IDL specifies interface
<TT>Example</TT>.</P><P>Note that, by default, local interface implementations have no
reference counting behaviour. If the local object should be deleted
when the last reference is released, the application must implement
the <TT>_add_ref()</TT> and <TT>_remove_ref()</TT> virtual member functions
within the implementation class. Make sure that the implementations
are thread safe.</P><!--TOC subsection Inheritance from unconstrained interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc167">11.8.2</A>&#XA0;&#XA0;Inheritance from unconstrained interfaces</H3><!--SEC END --><P>Local interfaces can inherit from unconstrained (i.e. non-local)
interfaces:</P><DIV CLASS="lstlisting"><B>module</B> Test {
  <B>interface</B> One {
    <B>void</B> problem(<B>inout</B> <B>string</B> arg);
  };
  <B>local</B> <B>interface</B> Two : One {
  };

  <B>interface</B> Receiver {
    <B>void</B> setOne(<B>in</B> One a);
  };
};</DIV><P>IDL like this leads to two issues to do with omniORB&#X2019;s C++ mapping
implementation.</P><P>First, an instance of local interface <TT>Two</TT> should be suitable to
pass as the argument to the <TT>setOne()</TT> method of a <TT>Receiver</TT>
object (as long as the object is in the same address space as the
caller). Therefore, the <TT>Two</TT> abstract base class has to inherit
from the internal class omniORB uses to map object references of type
<TT>One</TT>. For performance reasons, the class that implements
<TT>One</TT> object references normally has non-virtual member
functions. That means that the application-supplied <TT>problem()</TT>
member function for the implementation of local interface <TT>Two</TT>
will not override the base class&#X2019;s version. To overcome this, the IDL
for the base unconstrained interface must be compiled with the
<TT>-Wbvirtual-objref</TT> switch to omniidl. That makes the member
functions of the mapping of <TT>One</TT> into virtual functions, so they
can be overridden.</P><P>The second problem is that, in some cases, omniORB uses a different
mapping for object reference member functions than the mapping used in
servant classes. For example, in the <TT>problem()</TT> operation, it uses
an internal type for the inout string argument that avoids memory
issues if the application uses a <TT>String_var</TT> in the argument.
This means that the abstract member function declared in the
<TT>Two</TT> class (and implemented by the application) has a different
signature to the member function in the base class. The
application-supplied class will therefore not properly override the
base class method. In all likelihood, the C++ compiler will also
complain that the two member functions are ambiguous. The solution to
this problem is to use the implementation mapping in the base object
reference class, rather than the normal object reference mapping,
using the <TT>-Wbimpl-mapping</TT> switch to omniidl. The consequence
of this is that some uses of <TT>_var</TT> types for inout arguments
that are normally acceptable in omniORB can now lead to memory
management problems.</P><P>In summary, to use local interfaces derived from normal unconstrained
interfaces, you should compile all your IDL with the omniidl flags:</P><BLOCKQUOTE CLASS="quote">
<TT>-Wbvirtual-objref -Wbimpl-mapping</TT>
</BLOCKQUOTE><!--TOC subsection Valuetypes supporting local interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc168">11.8.3</A>&#XA0;&#XA0;Valuetypes supporting local interfaces</H3><!--SEC END --><P>According to the IDL specification, it should be possible to declare a
valuetype that supports a local interface:</P><DIV CLASS="lstlisting"><B>local</B> <B>interface</B> I {
  <B>void</B> my_operation();
};
<B>valuetype</B> V <B>supports</B> I {
  <B>public</B> <B>string</B> s;
};</DIV><P>omniidl accepts the IDL, but unfortunately the resulting C++ code does
not compile. The C++ mapping specification has a problem in that both
the <TT>CORBA::LocalObject</TT> and <TT>CORBA::ValueBase</TT>
classes have <TT>_add_ref()</TT> and <TT>_remove_ref()</TT> member
functions defined. The classes generated for the valuetype inherit
from both these base classes, and therefore have an ambiguity. Until
the C++ mapping resolves this conflict, valuetypes supporting local
interfaces cannot be used in omniORB.</P><!--TOC chapter Asynchronous Method Invocation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc169">Chapter&#XA0;12</A>&#XA0;&#XA0;Asynchronous Method Invocation</H1><!--SEC END --><P>
<A NAME="chap:ami"></A></P><P>omniORB 4.2 supports Asynchronous Method Invocation, AMI, as defined
in the CORBA Messaging specification. It supports both the polling and
callback models of asynchronous calls. Note that omniORB does not
support the other parts of the Messaging specification such as Quality
of Service, Routing and Persistent requests.</P><P>While omniORB mainly targets the 2.6 version of the CORBA
specification, the AMI support follows the CORBA Messaging
specification as described in the CORBA 3.1 specification, chapter
17&#XA0;[<A HREF="#corba31-spec">OMG08</A>]. That version of the specification is largely
the same as the one in CORBA 2.6. The only significant difference is
that exception replies in the callback model use a simpler
interface-independent mapping.</P><!--TOC section Implied IDL-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc170">12.1</A>&#XA0;&#XA0;Implied IDL</H2><!--SEC END --><P>AMI works by defining some additional <I>implied IDL</I> for each
interface in the real IDL. The implied IDL contains type and
operation definitions that enable asynchronous calls.</P><P>As a guide to the implied IDL, there is a special <TT>ami</TT>
back-end to omniidl that outputs the implied IDL for the given input
IDL. For example, given the Echo example IDL:</P><DIV CLASS="lstlisting"><I>// echo.idl</I>
<B>interface</B> Echo {
  <B>string</B> echoString(<B>in</B> <B>string</B> mesg);
};</DIV><P>You can output the implied IDL using</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bami echo.idl</TT>
</BLOCKQUOTE><P>That outputs the following to standard out:</P><DIV CLASS="lstlisting"><I>// ReplyHandler for interface Echo</I>
<B>interface</B> AMI_EchoHandler : Messaging::ReplyHandler {
  <B>void</B> echoString(<B>in</B> <B>string</B> ami_return_val);
  <B>void</B> echoString_excep(<B>in</B> ::Messaging::ExceptionHolder excep_holder);
};

<I>// Poller valuetype for interface Echo</I>
<B>abstract</B> <B>valuetype</B> AMI_EchoPoller : Messaging::Poller {
  <B>void</B> echoString(<B>in</B> <B>unsigned</B> <B>long</B> ami_timeout, <B>out</B> <B>string</B> ami_return_val);
};

<I>// AMI implied operations for interface Echo</I>
<B>interface</B> Echo {
  <B>void</B> sendc_echoString(<B>in</B> ::AMI_EchoHandler ami_handler, <B>in</B> <B>string</B> mesg);
  ::AMI_EchoPoller sendp_echoString(<B>in</B> <B>string</B> mesg);
};</DIV><P>Alternatively, you can use the <TT>-Wbdump</TT> option to
output an interleaved version that shows the original IDL and the
implied IDL together.</P><P>Note that the implied IDL output is for information only. You should
not compile it, but rather instruct the omniidl C++ back-end to
generate the corresponding C++ definitions.</P><!--TOC section Generating AMI stubs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc171">12.2</A>&#XA0;&#XA0;Generating AMI stubs</H2><!--SEC END --><P>To generate stub code including AMI types and operations, give the
<TT>-Wbami</TT> command line option to omniidl&#X2019;s <TT>cxx</TT>
back-end:</P><BLOCKQUOTE CLASS="quote">
<TT>omniidl -bcxx -Wbami echo.idl</TT>
</BLOCKQUOTE><P>That generates the normal C++ stubs and skeletons, plus all
the definitions in the implied IDL.</P><!--TOC section AMI examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc172">12.3</A>&#XA0;&#XA0;AMI examples</H2><!--SEC END --><P>Example AMI clients for the <TT>Echo</TT> server can be found in
<TT>src/examples/ami</TT>.</P><!--TOC chapter Interface Type Checking-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc173">Chapter&#XA0;13</A>&#XA0;&#XA0;Interface Type Checking</H1><!--SEC END --><P>
<A NAME="ch_intf"></A></P><P>This chapter describes the mechanism used by omniORB to ensure type
safety when object references are exchanged across the network. This
mechanism is handled completely within the ORB. There is no
programming interface visible at the application level. However, for
the sake of diagnosing the problem when there is a type violation, it
is useful to understand the underlying mechanism in order to interpret
the error conditions reported by the ORB.</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc174">13.1</A>&#XA0;&#XA0;Introduction</H2><!--SEC END --><P>In GIOP/IIOP, an object reference is encoded as an Interoperable
Object Reference (IOR) when it is sent across a network connection.
The IOR contains a Repository ID (RepoId) and one or more
communication profiles. The communication profiles describe where and
how the object can be contacted. The RepoId is a string which uniquely
identifies the IDL interface of the object.</P><P>Unless the <TT>ID</TT> pragma is specified in the IDL, the ORB generates
the RepoId string in the so-called OMG IDL Format<SUP><A NAME="text17" HREF="#note17">1</A></SUP>. For instance, the RepoId for the <TT>Echo</TT>
interface used in the examples of chapter&#XA0;<A HREF="#chap:basic">2</A> is
<TT>IDL:Echo:1.0</TT>.</P><P>When interface inheritance is used in the IDL, the ORB always sends the
RepoId of the most derived interface. For example:</P><DIV CLASS="lstlisting">   <I>// IDL</I>
   <B>interface</B> A {
     ...
   };
   <B>interface</B> B : A {
     ...
   };
   <B>interface</B> C {
      <B>void</B> op(<B>in</B> A arg);
   };</DIV><DIV CLASS="lstlisting">   <I>// C++</I>
   C_ptr server;
   B_ptr objB;
   A_ptr objA = objB;
   server-&gt;op(objA);  <I>// Send B as A</I></DIV><P>In the example, the operation <TT>C::op()</TT> accepts an object reference
of type <TT>A</TT>. The real type of the reference passed to <TT>C::op()</TT>
is <TT>B</TT>, which inherits from <TT>A</TT>. In this case, the RepoId of
<TT>B</TT>, and not that of <TT>A</TT>, is sent across the network.</P><P>The GIOP/IIOP specification allows an ORB to send a null string in the
RepoId field of an IOR. It is up to the receiving end to work out the
real type of the object. omniORB never sends out null strings as
RepoIds, but it may receive null RepoIds from other ORBs. In that
case, it will use the mechanism described below to ensure type safety.</P><!--TOC section Interface Inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc175">13.2</A>&#XA0;&#XA0;Interface Inheritance</H2><!--SEC END --><P>When the ORB receives an IOR of interface type B when it expects the
type to be A, it must find out if B inherits from A. When the ORB has
no local knowledge of the type B, it must work out the type of B
dynamically.</P><P>The CORBA specification defines an Interface Repository (IR) from
which IDL interfaces can be queried dynamically. In the above
situation, the ORB could contact the IR to find out the type of B.
However, this approach assumes that an IR is always available and
contains the up-to-date information of all the interfaces used in the
domain. This assumption may not be valid in many applications.</P><P>An alternative is to use the <TT>_is_a()</TT> operation to work out the
actual type of an object. This approach is simpler and more robust
than the previous one because no 3rd party is involved, so this is
what omniORB does.</P><DIV CLASS="lstlisting"><B>class</B> Object{
    CORBA::Boolean _is_a(<B>const</B> <B>char</B>* type_id);
};</DIV><P>The <TT>_is_a()</TT> operation is part of the <TT>CORBA::Object</TT>
interface and must be implemented by every object. The input argument
is a RepoId. The function returns <TT>true</TT> if the object is really
an instance of that type, including if that type is a base type of the
most derived type of that object.</P><P>In the situation above, the ORB would invoke the <TT>_is_a()</TT>
operation on the object and ask if the object is of type A
<EM>before</EM> it processes any application invocation on the object.</P><P>Notice that the <TT>_is_a()</TT> call is <EM>not</EM> performed when the IOR
is unmarshalled. It is performed just prior to the first application
invocation on the object. This leads to some interesting failure modes
if B reports that it is not an A. Consider the following example:</P><DIV CLASS="lstlisting"><I>// IDL</I>
<B>interface</B> A { ... };
<B>interface</B> B : A { ... };
<B>interface</B> D { ... };
<B>interface</B> C {
  A      op1();
  <B>Object</B> op2();
};</DIV><DIV CLASS="lstlisting"><FONT SIZE=1>   1</FONT> <I>// C++</I>
<FONT SIZE=1>   2</FONT> C_ptr objC;
<FONT SIZE=1>   3</FONT> A_ptr objA;
<FONT SIZE=1>   4</FONT> CORBA::Object_ptr objR;
<FONT SIZE=1>   5</FONT> 
<FONT SIZE=1>   6</FONT> objA =  objC-&gt;op1();
<FONT SIZE=1>   7</FONT> (<B>void</B>) objA-&gt;_non_existent();
<FONT SIZE=1>   8</FONT> 
<FONT SIZE=1>   9</FONT> objR =  objC-&gt;op2();
<FONT SIZE=1>  10</FONT> objA =  A::_narrow(objR);</DIV><P>If the stubs of A,B,C,D are linked into the executable and:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Case 1</B></DT><DD CLASS="dd-description"> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a B. Lines 6&#X2013;10
complete successfully. The remote object is only contacted at line 7.</DD><DT CLASS="dt-description"><B>Case 2</B></DT><DD CLASS="dd-description"> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a D. This condition
only occurs if the runtime of the remote end is buggy. Even though the
IDL definitions show that D is not derived from A, omniORB gives it
the benefit of the doubt, in case it actually has a more derived
interface that is derived from both A and D. At line 7, the object is
contacted to ask if it is an A. The answer is no, so a
<TT>CORBA::INV_OBJREF</TT> exception is raised. At line 10, the narrow
operation will fail, and objA will be set to nil.
</DD></DL><P>If only the stubs of A are linked into the executable and:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Case 1</B></DT><DD CLASS="dd-description"> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a B. Lines 6&#X2013;10
complete successfully. When lines 7 and 10 are executed, the object is
contacted to ask if it is an A.</DD><DT CLASS="dt-description"><B>Case 2</B></DT><DD CLASS="dd-description"> <TT>C::op1()</TT> and <TT>C::op2()</TT> return a D. This condition
only occurs if the runtime of the remote end is buggy. Line 6
completes and no exception is raised. At line 7, the object is
contacted to ask if it is an A. If the answer is no, a
<TT>CORBA::INV_OBJREF</TT> exception is raised. At line 10, the narrow
operation will fail, and objA will be set to nil.
</DD></DL><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note17" HREF="#text17">1</A></DT><DD CLASS="dd-thefootnotes">For further
details of the repository ID formats, see section 10.6 in the CORBA
2.6 specification.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Packaging stubs into DLLs-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc176">Chapter&#XA0;14</A>&#XA0;&#XA0;Packaging stubs into DLLs</H1><!--SEC END --><P>
<A NAME="chap:dlls"></A></P><P>omniORB&#X2019;s stubs can be packaged into shared libraries or DLLs. On Unix
platforms this is mostly painless, but on Windows things are slightly
more tricky.</P><!--TOC section Dynamic loading and unloading-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc177">14.1</A>&#XA0;&#XA0;Dynamic loading and unloading</H2><!--SEC END --><P>As long as your platform supports running static initialisers and
destructors as libraries are loaded and unloaded, you can package
stubs into shared libraries / DLLs, and load them dynamically at
runtime.</P><P>There is one minor problem with this, which is that normally nil
object references are heap allocated, and only deallocated when the
ORB is destroyed. That means that if you unload a stub library from
which nil references have been obtained (just by creating an object
reference _var for example), there is a risk of a segmentation fault
when the ORB is destroyed. To avoid that problem, define the
<TT>OMNI_UNLOADABLE_STUBS</TT> C pre-processor symbol while you are
compiling the stub files. Unfortunately, with that define set, there
is a risk that object reference _vars at global scope will segfault
as they are unloaded. You must not create _vars at global scope if
you are using <TT>OMNI_UNLOADABLE_STUBS</TT>.</P><!--TOC section Windows DLLs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc178">14.2</A>&#XA0;&#XA0;Windows DLLs</H2><!--SEC END --><P>On Unix platforms, the linker figures out how to link the symbols
exported by a library in to the running program. On Windows,
unfortunately, you have to tell the linker where symbols are coming
from. This causes all manner of difficulties.</P><!--TOC subsection Exporting symbols-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc179">14.2.1</A>&#XA0;&#XA0;Exporting symbols</H3><!--SEC END --><P>To (statically) link with a DLL file in Windows, you link with a LIB
file which references the symbols exported from the DLL. To build the
LIB and DLL files, the correct symbols must be exported. One way to do
that is to decorate the source code with magic tags that tell the
compiler to export the symbols. The alternative is to provide a DEF
file that lists all the symbols to be exported. omniORB uses a DEF
file.</P><P>The question is, how do you create the DEF file? The answer is to use
a Python script named <TT>makedeffile.py</TT> that lives in the
<TT>bin\scripts</TT> directory in the omniORB distribution.
<TT>makedeffile.py</TT> runs the dumpbin program that comes with
Visual C++, and processes its output to extract the necessary symbols.
Although it is designed for exporting the symbols from omniORB stub
files, it can actually be used for arbitrary C++ code. To use it to
create a DLL from a single source file, use the following steps:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Compile the source:<P><TT>cl -c -O2 -MD -GX -Fofoo.o -Tpfoo.cc</TT></P></LI><LI CLASS="li-enumerate">Build a static library (It probably won&#X2019;t work on its own due to
the -MD switch to cl, but we just need it to get the symbols
out):<P><TT>lib -out:foo_static.lib foo.o</TT></P></LI><LI CLASS="li-enumerate">Use the script to build a .def file:<P><TT>makedeffile.py foo_static.lib foo 1.0 foo.def</TT></P></LI><LI CLASS="li-enumerate">Build the .dll and .lib with the def file.<P><TT>link -out:foo.dll -dll -def:foo.def -implib:foo.lib foo.o</TT>
</P></LI></OL><P>Of course, you can link together many separate C++ files, rather than
just the one shown here.</P><!--TOC subsection Importing constant symbols-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc180">14.2.2</A>&#XA0;&#XA0;Importing constant symbols</H3><!--SEC END --><P>As if exporting the symbols from a DLL was not complicated enough, any
constant values exported by a DLL have to be explicitly
<EM>imported</EM> into the code using them. omniORB&#X2019;s stub files declare
a number of such constants. This time, the constant declarations in
the generated header files are decorated in a way that tells the
compiler what to do. When the stub headers are #included, the correct
pre-processor defines must be set. If things are not set correctly,
the code all links without problems, but then mysteriously blows up at
run time.</P><P>Depending on how complex your situation is, there are a range of
solutions. Starting with the simplest, here are some scenarios you may
find yourself in:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">All stub code, and all code that uses it is wrapped up in a
single DLL.<P>Do nothing special.</P></LI><LI CLASS="li-enumerate">All stub code is in a single DLL. Code using it is in another
DLL, or not in a DLL at all.<P><TT>#define USE_stub_in_nt_dll</TT> before <TT>#include</TT> of
the stub headers.</P></LI><LI CLASS="li-enumerate">The stubs for each IDL file are in separate DLLs, one DLL per
IDL file.<P>In this case, if the IDL files <TT>#include</TT> each other, then
when the stub files are compiled, import declarations are needed
so that references between the separate DLLs work. To do this,
first compile the IDL files with the <TT>-Wbdll_stubs</TT>
flag:</P><P><TT>omniidl -bcxx -Wbdll_stubs example.idl</TT></P><P>Then define the <TT>INCLUDED_stub_in_nt_dll</TT> pre-processor
symbol when compiling the stub files. As above, define
<TT>USE_stub_in_nt_dll</TT> when including the stub headers
into application code.</P></LI><LI CLASS="li-enumerate">Stubs and application code are packaged into multiple DLLs, but
DLLs contain the stubs for more than one IDL file.<P>This situation is handled by &#X2018;annotating&#X2019; the IDL files to
indicate which DLLs they will be compiled into. The annotation
takes the form of some <TT>#ifdefs</TT> to be inserted in the
stub headers. For example,</P><DIV CLASS="lstlisting"><I>// one.idl</I>

<B>#pragma</B> hh #ifndef COMPILING_FIRST_DLL
<B>#pragma</B> hh # ifndef USE_stub_in_nt_dll
<B>#pragma</B> hh #   define USE_stub_in_nt_dll
<B>#pragma</B> hh # endif
<B>#pragma</B> hh #endif

<B>#include</B> &lt;two.idl&gt;

<B>module</B> ModuleOne {
  ...
};


<I>// two.idl</I>

<B>#pragma</B> hh #ifndef COMPILING_SECOND_DLL
<B>#pragma</B> hh # ifndef USE_stub_in_nt_dll
<B>#pragma</B> hh #   define USE_stub_in_nt_dll
<B>#pragma</B> hh # endif
<B>#pragma</B> hh #endif

<B>#include</B> &lt;three.idl&gt;
...</DIV><P>Here, <TT>one.idl</TT> is packaged into <TT>first.dll</TT> and
<TT>two.idl</TT> is in <TT>second.dll</TT>. When compiling
<TT>first.dll</TT>, the <TT>COMPILING_FIRST_DLL</TT> define is
set, meaning definitions from <TT>one.idl</TT> (and any other
files in that DLL) are not imported. Any other module that
includes the stub header for <TT>one.idl</TT> does not define
<TT>COMPILING_FIRST_DLL</TT>, and thus imports the necessary
symbols from the DLL.</P><P>Rather than explicitly listing all the pre-processor code, it
can be cleaner to use a C++ header file for each DLL. See the
COS services IDL files in <TT>idl/COS</TT> for an example.</P></LI></OL><!--TOC chapter Resources-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc181">Chapter&#XA0;15</A>&#XA0;&#XA0;Resources</H1><!--SEC END --><P>There are a number of useful online resources related to omniORB:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><A HREF="http://omniorb.sourceforge.net/"><TT>http://omniorb.sourceforge.net/</TT></A> is the main omniORB web
site.</LI><LI CLASS="li-itemize">The omniORB FAQ is at <A HREF="http://omniorb.sourceforge.net/faq.html"><TT>http://omniorb.sourceforge.net/faq.html</TT></A></LI><LI CLASS="li-itemize">The omniORB mailing list is the first port of call for questions
that are not answered in this document or in the FAQ. Subscription
information and archives are at
<A HREF="http://omniorb.sourceforge.net/list.html"><TT>http://omniorb.sourceforge.net/list.html</TT></A></LI><LI CLASS="li-itemize">Commercial support is available from
<A HREF="http://www.omniorb-support.com/"><TT>http://www.omniorb-support.com/</TT></A></LI></UL><!--TOC chapter References-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->References</H1><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="rfc2396"><FONT COLOR=purple>[BLFIM98]</FONT></A></DT><DD CLASS="dd-thebibliography">
T. Berners-Lee, R. Fielding, U.C. Irvine, and L. Masinter.
<EM>U</EM><EM>niform </EM><EM>R</EM><EM>esource </EM><EM>I</EM><EM>dentifiers (</EM><EM>URI</EM><EM>): Generic Syntax</EM>.
RFC 2396, August 1998.</DD><DT CLASS="dt-thebibliography"><A NAME="henning1999"><FONT COLOR=purple>[HV99]</FONT></A></DT><DD CLASS="dd-thebibliography">
Michi Henning and Steve Vinoski.
<EM>Advanced </EM><EM>CORBA</EM><EM> Programming with </EM><EM>C++</EM>.
Addison-Wesley professional computing series, 1999.</DD><DT CLASS="dt-thebibliography"><A NAME="corbaservices"><FONT COLOR=purple>[OMG98]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>CORBAServices</EM><EM>: Common Object Services Specification</EM>, December
1998.</DD><DT CLASS="dt-thebibliography"><A NAME="inschapters"><FONT COLOR=purple>[OMG00]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>Interoperable Naming Service revised chapters</EM>, August 2000.
From <A HREF="http://www.omg.org/cgi-bin/doc?ptc/00-08-07"><TT>http://www.omg.org/cgi-bin/doc?ptc/00-08-07</TT></A>.</DD><DT CLASS="dt-thebibliography"><A NAME="corba26-spec"><FONT COLOR=purple>[OMG01]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>The </EM><EM>C</EM><EM>ommon </EM><EM>O</EM><EM>bject </EM><EM>R</EM><EM>equest </EM><EM>B</EM><EM>roker: </EM><EM>A</EM><EM>rchitecture and
Specification</EM>, 2.6 edition, December 2001.
From <A HREF="http://www.omg.org/cgi-bin/doc?formal/01-12-01"><TT>http://www.omg.org/cgi-bin/doc?formal/01-12-01</TT></A>.</DD><DT CLASS="dt-thebibliography"><A NAME="cxxmapping"><FONT COLOR=purple>[OMG03]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>C++ Language Mapping</EM>, 1.1 edition, 2003.
From <A HREF="http://www.omg.org/cgi-bin/doc?formal/03-06-03"><TT>http://www.omg.org/cgi-bin/doc?formal/03-06-03</TT></A>.</DD><DT CLASS="dt-thebibliography"><A NAME="corba31-spec"><FONT COLOR=purple>[OMG08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Object Management Group.
<EM>The </EM><EM>C</EM><EM>ommon </EM><EM>O</EM><EM>bject </EM><EM>R</EM><EM>equest </EM><EM>B</EM><EM>roker: </EM><EM>A</EM><EM>rchitecture and
Specification</EM>, 3.1 edition, January 2008.
From <A HREF="http://www.omg.org/cgi-bin/doc?formal/08-01-04"><TT>http://www.omg.org/cgi-bin/doc?formal/08-01-04</TT></A>.</DD><DT CLASS="dt-thebibliography"><A NAME="tjr96a"><FONT COLOR=purple>[Ric96]</FONT></A></DT><DD CLASS="dd-thebibliography">
Tristan Richardson.
<EM>The </EM><EM>OMNI</EM><EM> Thread Abstraction</EM>.
AT&amp;T Laboratories Cambridge, October 1996.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
